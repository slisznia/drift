# Drift development history

## 2025-11-20
- Captured the `lang.core.source_location` helper in the spec as a zero-cost intrinsic that lowers to the current file/line. Kept the data shape explicit (`SourceLocation` struct) so callsites can choose when to capture site metadata, thread it through `^` context bindings, or pass it into exceptions; avoided auto-injecting locations in the runtime to keep logging/telemetry opt-in. (Prototype interpreter still needs the intrinsic wired in.)
- Hardened comment and error conventions: grammar now allows both `//` line comments and `/* ... */` block comments (non-nesting) so we can annotate examples without fighting terminator insertion. Documented a standard `IndexError(container, index)` event for out-of-bounds accesses to make future bounds checks report consistent payloads instead of ad-hoc errors.
- Elevated error declarations to first-class language items with an `exception` keyword, aligning them with structs so constructors are typed and usable from the interpreter. Fixed the parser to ignore non-Tree nodes when assembling parameter lists, preventing stray tokens/comments from polluting function signatures. Added playground coverage for captures and structs so the sample suite exercises the new constructs.
- Tightened tooling guardrails: the draft linter now enforces tabs (default) vs spaces and checks snake_case/PascalCase across functions, parameters, bindings, structs, and exceptions to keep examples consistent with the style guide. The `just` recipes parse both `playground/` and `examples/` to catch grammar regressions immediately; we deliberately stayed with a lightweight custom linter instead of a full formatter while the syntax is still in flux.
- Worked through module signing requirements and concluded the pipeline should canonically sign an ANF-like DMIR and lower to SSA MIR for optimization/codegen; added an overview of that split to `docs/design-first-afm-then-ssa.md`.
- Adopted a policy of fully monomorphizing generics (no shared reified bodies) so DMIR/SSA always see concrete types; watch for code-size blowups in heavily polymorphic code, but favor optimizer simplicity and performance first.
- Added a DMIR draft spec and cleaned up primitive notes (ConsoleOut treated as runtime-provided only). Expanded control surface with ternary `?:`, plus try/catch and inline try/else support wired through grammar, parser, checker, interpreter, linter, and new runtime tests (including a ternary test case in `tests/`).
- Runtime now enforces array bounds with `IndexError(container, index)` and prints errors in the spec’s structured format with a simple call-stack capture; added runtime tests for out-of-bounds and error reporting.
- Documented DMIR canonicalization rules (naming, ordering, kwarg normalization) and added surface→DMIR examples for ternary, try/else, and constructors to stabilize the signing format. Approved SSA MIR control-flow model and value/ownership rules (monomorphized, move-only by default, explicit error edges, drops in MIR).
- Documented the SSA MIR instruction palette (const/move/copy/call with normal+error edges, struct/array ops, unary/binary, drop) in `docs/dmir-spec.md`; TODO updated accordingly.
