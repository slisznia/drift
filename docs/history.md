# Drift development history

## 2025-12-01
- Hardened exception event codes: `Error.code` is `I64` with a 4+60 bit layout (kinds + payload), user exceptions hash their FQN via xxHash64, per-module collisions are rejected, and metadata now records FQN/kind/payload/event_code for future export.
- Updated runtime dummy helper to carry code + first payload; added C runtime tests to validate kind/payload packing across multiple inputs. `test-runtime-c` runs via `CLANG_BIN` (default clang-15).
- Try/catch expression dispatch fixed to use `I64` constants; added SSA programs for expr event dispatch (single and multi catch) to pin the lowering.
- Extended `drift-abi-exceptions.md` with the explicit kind/payload bit layout and reserved kinds, aligning checker/runtime/backend to the ABI.

## 2025-11-30
- Added deterministic event codes to exception definitions and wired SSA try/catch dispatch (stmt + expr) to project `ErrorEvent` and branch to matching catches with catch-all fallback/rethrow semantics; both stmt and expr event-catch tests now run end-to-end.
- Introduced a first-class `ErrorEvent` MIR instruction, SSA helper, and LLVM lowering that calls `drift_error_get_code`; the dummy runtime and a new SSA test (`mir_ssa_error_event_test`) prove the projection end-to-end.
- SSA backend now asserts MIR-provided can-error markings and uses `{T, Error*}` / `Error*` ABI for throws and call edges; SSA/e2e runners link against `error_dummy` by default for error-edge coverage. SSA e2e subset now covers hello/throw + try/catch + event dispatch via `test-e2e-ssa-subset`.
- try/catch work-progress document refreshed to mark Phase 1 (event dispatch) complete and capture current SSA e2e subset coverage.

## 2025-11-29
- SSA-first pipeline is now the only maintained path: `driftc` lowers every function to SSA, runs the simplifier and strict verifier, and the e2e runner uses the new SSA→LLVM backend to compile, link, and run real programs (hello, pure calls, console writes, structs by ref, arrays/for loops). Legacy lowering/codegen is deprecated.
- SSA→LLVM backend now handles multi-function modules, control flow with PHIs from block params, pure calls, string literals, console runtime calls, struct init/field get/set using checker-provided layouts, array len/get/set and stack array literals, and word-sized `Int` mapping (Int/Int64 → i64, Int32 → i32, Bool → i1, String → `DriftString`).
- Array lowering generalized: `{len: Size, data: T*}` works for any element type the backend can map (not just ints). Added a run-mode e2e `array_string` to prove `Array<String>` works; array literals now build a stack buffer of the element LLVM type and assemble the header. Bounds/len access reuse the same layout; unsupported element types hard-error.
- Checker alignment: array indices are `Int` (word-sized) for both reads and writes; SSA smoke/programs updated to use `Int` instead of `Int64`. Negative index/field tests updated to the new messages.
- Struct support tightened: `StructLayout` is threaded from the checker into SSA codegen; field get/set pick the correct layout via per-function SSA type maps (no cross-struct field-name guessing). Ref-struct mutation runs in e2e via SSA→LLVM with stack slots for struct locals.
- Tests/e2e: SSA-only smoke/program suites are green; run-mode e2e covers hello, pure calls, console writes, control flow, arrays/for, struct mutation, and array-of-strings. Added a compile-fail `bad_index` with the updated `Int` expectation. Simplifier runs in the SSA path by default.

## 2025-11-26
- Retired the legacy interpreter path: test runner no longer executes `drift.py` runtime programs; focus is MIR+codegen only.
- Revised borrowing syntax to `&T` / `&mut T` with global lvalue auto-borrowing and no borrowing from rvalues; receivers now use `self: T` / `self: &T` / `self: &mut T` throughout the spec and examples. Grammar updated to accept the new reference types and borrow expressions; lambda params now use explicit `copy` capture instead of reusing general params. Removed legacy `ref` spellings (now invalid), refreshed README examples, and aligned the iterator doc to the new syntax.
- Archived former interpreter tests under `tests/legacy/` and duplicated them as `tests/mir_codegen/runtime_*` stubs so they can be turned back on once I/O and strings are supported in codegen.
- Updated numeric primitives in the spec: natural-width `Int`/`Uint`/`Size`/`Float` as defaults, fixed-width `Int8`…`Int64`/`Uint8`…`Uint64`/`F32`/`F64` for explicit widths; added overflow/convert rules, mandated `Size` for lengths/indices, and added FFI numeric mapping guidance (C widths → Drift types) plus an FFI wrapper pattern. Array helpers now use `Size` for indices.
- Added string runtime stubs (`DriftString` layout + constructors/concat/free/to_cstr`) in the codegen runtime, and ported legacy runtime samples into `tests/mir_codegen/runtime_*` (currently skipped until string/console codegen lands).
- Hardened string runtime: lengths use `uintptr_t`, helpers always include trailing NUL, added an empty-string helper, C++ guards, and crash-fast on malloc failures to keep ABI consistent with the numeric/size rules.
- Lowered `throw` of an exception constructor into a real `Error*`: pick `msg` kwarg/first positional or fall back to the exception name, call builtin `error_new`, and raise that pointer. Added an `error_new` builtin signature/stub for interpreter parity.
- MIR→LLVM now seeds successor environments correctly and treats helper calls (`error_new`/`error`) as returning bare `Error*` while other calls with error edges expect `{T, Error*}`. This fixed undefined-SSA issues in the emitter.
- Switched codegen to PIC/PIE: LLVM target machine uses `reloc="pic"`, C stubs/harness are built with `-fPIC`, and we link with `-pie` so we no longer need `-no-pie` or see text-relocation warnings.
- Unskipped the error-path codegen test and added a success-path sibling (`tests/mir_codegen/error_path_ok`) so both error and non-error return flows are exercised end-to-end.
- Defined a stable Error C ABI in the spec (UTF-8 strings, attrs/frames layout, ownership rules) and wired runtime stubs to match (`drift_error_new`, owned diagnostics, no static buffers). `throw` lowering now targets `drift_error_new`, and MIR→LLVM treats it as returning `Error*`. Added try/else and try/catch codegen cases and updated MIR goldens accordingly; all codegen tests pass.
- Added frame-array plumbing: lowering captures throw-site frames (file basename, func, line) and passes them to `drift_error_new`; MIR→LLVM supports string/int64 array init; runtime stubs store frames and free them; added `error_push_frame` hook for future deeper stacks. Added attr-array codegen tests (including large sets) to validate deterministic attrs and frame handling. Spec now notes the hidden ctx must never affect the public C ABI.
- Extended MIR lowering to handle `try/catch` statements: errors in the try body branch to a catch block (binder typed as `Error`), with a new MIR golden `tests/mir_lowering/try_catch.mir` covering the shape.
- Calls now always branch on `{T, Error*}` with explicit normal/error continuations: lowering wraps calls with normal/error blocks and a join, and the error path forwards to enclosing handlers so outer `try/catch` can intercept. Caller frames use call-site source lines, and throw-site frames use source basename/function/line. Added deep-frame codegen cases (`frames_chain`, `frames_one/two/three`) and domain default/override tests to exercise propagation.
- Added module declarations and threaded module IDs through checking/lowering/MIR→LLVM so frame metadata now includes modules (plus file/func/line); frame files were normalized to basenames. Updated the C error ABI (`struct Error`, `drift_error_new`, `error_push_frame`) and frame codegen tests to capture/print module-aware stacks.
- Error diagnostics now emit valid JSON with event/domain/attrs and a `frames` array of `{module,file,func,line}` objects; the runtime builds the string lazily in `error_to_cstr`. Exception `domain` parsing now unquotes string literals so domains print without double quotes. Updated the codegen expectations for attr arrays, error paths, and frame tests to the new JSON shape.
- Added per-frame captured locals to the error payload: runtime ABI now carries `cap_keys/values` and per-frame counts, lowering threads `^` bindings into throw/call error paths, and `error_to_cstr` emits `captured:{...}` per frame. Added a multi-level codegen test (`tests/mir_codegen/frames_captures`) to assert captured locals across the stack; updated frame expectations accordingly.
- Enforced canonical module IDs at compile time (lowercase alnum with dots/underscores, no leading/trailing/consecutive separators, ≤254 UTF-8 bytes, reserved prefixes blocked); frames record declared module IDs only. Added negative tests for invalid/reserved module IDs and documented import aliasing (aliases do not affect frame metadata). Fixed linter spacing in the new module tests.
- Added `while` loops end-to-end (grammar, parser, checker, interpreter, MIR lowering), plus runtime tests for simple, nested, and nested-with-try/catch loops. Import alias support was added to the grammar/spec.
- Added `break`/`continue` tokens to the grammar and loop-scoping checks in the checker; added a nested while+try/catch runtime test (`while_try_catch.drift`). Documented control-flow (if/else, ternary, while, try/else, try/catch) in the language spec.
- Expanded reserved keywords: checker now rejects a broad set (language/FFI/legacy keywords, lowercase primitive aliases); added a negative test for using a reserved word as a function name; spec reserved-keyword list updated.
- Clarified that `Bool` lowers to LLVM `i1`; kept `true`/`false` as lowercase literals, so constructs like `while true { ... }` parse and type-check as expected. History/spec updated to reflect the current control-flow and reserved keyword rules.
- Reordered the language spec chapters for better definition-before-use flow (traits/interfaces early, variants before exceptions/null safety, arrays/collections grouped, standard I/O moved later) and renumbered chapters sequentially without duplicates.
- Error edges fully integrated end-to-end: `throw` now lowers through MIR→SSA→LLVM using the `{T, Error*}` / `Error*` ABI, and new e2e tests (`throw_try`, `void_throw`) cover both value+error and void can-error paths. SSA call-edge tests now include throwing and void callees.
- Generic SSA lowering now handles can-error functions without hand-crafted MIR: special cases for `may_fail_error`, `may_throw`, and `maybe_fail` were removed, relying on normal lowering plus can-error tagging.
- MIR `Function` now carries a `can_error` flag propagated from throws and call-with-edges; SSA codegen enforces can-error invariants (returns carry error operands, calls-with-edges only target can-error functions, plain calls to can-error functions are rejected).
- SSA lowering handles `RaiseStmt` and prunes unused join blocks in `if` lowering; throw lowering uses safe placeholder values in pairs.
- Added FFI-based plugin stance to the spec, clarified static modules/exports as can-throw entry points, and tightened DMIR export semantics to cover static modules only. Drift-native plugin ABI was removed in favor of FFI guidance.

## 2025-11-24
- Fixed the parser’s `if` builder to grab the nested `else_clause` block, so conditional statements with an else arm are preserved through parsing and lowering.
- Extended straight-line MIR lowering to handle `if/else` control flow (joins only when needed) and to reject functions that fall off without a return. Added a MIR golden for `if_else` in `tests/mir_lowering/` to cover the path.
- Aligned ternary lowering with a typed phi param at the join and updated the expected MIR formatting to match the printer/block ordering.
- Documented the FFI callback rules in the spec: only non-capturing functions cross the C ABI as callbacks; captured closures are not auto-boxed and require an explicit, manual state+trampoline if ever needed. Added a note for callbacks returned from C: treat function pointers (and optional ctx) as borrowed, enforce cdecl, block unwinding into C, and don’t assume ownership of ctx unless the API says so.
- Clarified destructor semantics in the spec: deterministic RAII at end-of-liveness (scope exit, early return, or consumption), move-only by default to avoid double drops, and copies only for `Copy` types with a defined copy+drop story.
- Clarified interface ownership: owned interface types should require `Destructible` so vtables always expose a drop slot; borrowed interface views omit destruction.
- Added a DMIR vtable section: interface values are fat pointers `{data, vtable}`; owned views require `Destructible` and dispatch `drop` via the vtable, borrowed views omit the drop slot, and vtable ordering is stable across inheritance (base entries first).
- Clarified multi-interface vtables: each interface gets its own per-type vtable; no merging across interfaces. Inheritance keeps base entries (including drop) at fixed offsets.
- Noted that a concrete type has a single destructor; every owned interface vtable for that type points its drop slot to the same concrete drop, so dropping via any interface dispatches identically.
- Stated explicitly in the spec: no class/struct inheritance; composition + traits + interfaces replace it to keep layout/ABI stable and avoid fragile-base/diamond issues.
- Added a closure preview to the spec: `|params| => expr` syntax with implicit return for expressions and explicit return for block form; explicit capture modes (default move consumes binding; `copy x` keeps a `Copy` value usable; borrow captures planned later alongside borrow/lifetime checking) to keep ownership clear; capturing closures lower to `{env_ptr, call_ptr}` with a single env destructor; non-capturing are thin function pointers; callable interfaces (`Fn`/`FnMut`/`FnOnce` style) can be auto-implemented based on capture mutability.
- Added an explicit `copy <expr>` expression to force duplication of `Copy` values (errors on non-`Copy`), usable in call args, closure captures, or bindings.
- Added a DMIR note for closures: capturing closures are fat `{env_ptr, call_ptr}` with a single env drop; non-capturing are thin pointers; callable interfaces can target the closure thunk/env.
- Added callable-usage examples: a single `Callable<Args, R>` interface with usage determined by how it’s passed—`ref` for pure reuse, `ref mut` for stateful reuse, by value to consume (single-use for move-only callables, duplicating `Copy` ones).
- Added a TODO track for closure implementation: lower closure literals to `{env_ptr, call_ptr}`, generate thunks, represent thin/fat closures in MIR/LLVM with env drops, wire callable invocation/desugaring, and add borrow captures once borrow checking is available.
- Clarified DMP threat model and verification: signatures are checked only at import/compile time (not at runtime), and DMP guards against supply-chain tampering, not against attackers who already control the compiler/linker/runtime.
- Extended the MIR verifier’s dataflow: propagate defs/types across blocks and use propagated types for edge arg checking; CFG validation now uses out-state from the dataflow pass.
- Wired the MIR verifier into MIR golden tests; fixed edge checking to use propagated out-state so branch/phi args and returns validate across blocks.
- Integrated MIR verification into `driftc` so MIR is checked before LLVM codegen in the `mir-codegen` path.
- Added negative verifier tests (use-before-def, edge arity mismatch) to the test runner to ensure the verifier rejects bad MIR.
- Added a dominance-violation negative test (missing join arg) to the verifier suite to ensure defs must reach all predecessors.
- Added an edge type-mismatch negative test to cover edge param type validation.
- Added an edge undefined-arg negative test to ensure edges only reference values defined in the source block.
- Added ownership negative tests (use-after-move, double-drop) to exercise the verifier’s ownership rules.
- Added a return-type mismatch negative test to ensure returns match the function’s declared type.
- Added an error-edge type negative test to ensure `raise` carries `Error` and error edges have correct types.
- Added a missing-terminator negative test to enforce that every block ends in a terminator.
- Added an unknown-block negative test to ensure edges cannot target nonexistent blocks.
- Added an end-to-end MIR→LLVM→clang codegen test harness (`tests/mir_codegen/`), with a sample add case; harness is skipped when llvmlite/clang-15 are unavailable.
- Restored call normal/error edges and treated call-with-edges as terminators in the verifier/CFG/dataflow; MIR→LLVM now branches to call successors (placeholder success check; error payload TBD).
- Documented the Error ABI: errors are heap-allocated `Error*` owned by the caller; calls return `{T, Error*}` (or `Error*` for Error returns), branch on `err == null`, and propagate the pointer along error edges; handlers/freeing happen at catch/top-level.
- Defined the Error object layout for the ABI: `Error*` heap object with event id/name, preformatted args, ctx frames, backtrace handle; opaque to user code; caller frees via `error_free` unless propagating.
- Lowered `raise` in MIR→LLVM: returns an `{T, Error*}` pair with the error pointer (or `Error*` directly for Error-returning functions) along the error path; still a placeholder until full error ABI is wired through calls.
- Added a codegen skip for the planned error-path test until runtime error helpers and real error ABI wiring are in place.

## 2025-11-20
- Captured the `lang.core.source_location` helper in the spec as a zero-cost intrinsic that lowers to the current file/line. Kept the data shape explicit (`SourceLocation` struct) so callsites can choose when to capture site metadata, thread it through `^` context bindings, or pass it into exceptions; avoided auto-injecting locations in the runtime to keep logging/telemetry opt-in. (Prototype interpreter still needs the intrinsic wired in.)
- Hardened comment and error conventions: grammar now allows both `//` line comments and `/* ... */` block comments (non-nesting) so we can annotate examples without fighting terminator insertion. Documented a standard `IndexError(container, index)` event for out-of-bounds accesses to make future bounds checks report consistent payloads instead of ad-hoc errors.
- Elevated error declarations to first-class language items with an `exception` keyword, aligning them with structs so constructors are typed and usable from the interpreter. Fixed the parser to ignore non-Tree nodes when assembling parameter lists, preventing stray tokens/comments from polluting function signatures.
- Tightened tooling guardrails: the draft linter now enforces tabs (default) vs spaces and checks snake_case/PascalCase across functions, parameters, bindings, structs, and exceptions to keep examples consistent with the style guide. The `just` recipes parse examples to catch grammar regressions immediately; we deliberately stayed with a lightweight custom linter instead of a full formatter while the syntax is still in flux.
- Worked through module signing requirements and concluded the pipeline should canonically sign an ANF-like DMIR and lower to SSA MIR for optimization/codegen; added an overview of that split to `docs/design-first-afm-then-ssa.md`.
- Adopted a policy of fully monomorphizing generics (no shared reified bodies) so DMIR/SSA always see concrete types; watch for code-size blowups in heavily polymorphic code, but favor optimizer simplicity and performance first.
## 2025-11-23
- Added a DMIR draft spec and cleaned up primitive notes (ConsoleOut treated as runtime-provided only). Expanded control surface with ternary `?:`, plus try/catch and inline try/else support wired through grammar, parser, checker, interpreter, linter, and new runtime tests (including a ternary test case in `tests/`).
- Runtime now enforces array bounds with `IndexError(container, index)` and prints errors in the spec’s structured format with a simple call-stack capture; added runtime tests for out-of-bounds and error reporting.
- Documented DMIR canonicalization rules (naming, ordering, kwarg normalization) and added surface→DMIR examples for ternary, try/else, and constructors to stabilize the signing format. Approved SSA MIR control-flow model and value/ownership rules (monomorphized, move-only by default, explicit error edges, drops in MIR).
- Documented the SSA MIR instruction palette (const/move/copy/call with normal+error edges, struct/array ops, unary/binary, drop) in `docs/dmir-spec.md`; TODO updated accordingly.
- Added end-to-end surface→DMIR→SSA MIR examples (ternary, inline try/else with fallback) to ground the IR design.
- Added SSA MIR terminology/conventions (block labels, params-as-φ, SSA defs, explicit call successors, ownership rules).
- Added a CFG block notation alongside the ternary SSA example to visualize control flow and φ-like params.
- Added CFG notation to the try/else SSA example for readability.
- Added verifier expectations to the SSA MIR terminology section (SSA dominance, types, ownership, drops, terminators).
- Added a MIR verifier checklist to the DMIR spec so readers know the invariants to enforce before optimizations/codegen.
- Added initial MIR data structures (`lang/mir.py`) to model SSA blocks, instructions, edges, and programs; tests still pass.
- Tightened the String ABI plan: compiler never calls `drift_string_literal`; literals stay as static `%drift.String` constants. Renamed the runtime constructor to `drift_string_from_utf8_bytes` to make encoding explicit and aligned LLVM decls to the new symbol.
- Added console runtime stubs (`drift_console_write/writeln` taking `DriftString` by value), wired MIR with `ConsoleWrite/ConsoleWriteln` instructions, and lowered them in MIR→LLVM via the matching runtime decls.
- Updated the `test` just target to drop linting of the legacy interpreter programs to avoid keeping that folder in sync.
- Added a skeleton MIR verifier (`lang/mir_verifier.py`) covering SSA def/use, ownership moves/drops, edge/param arity, and basic terminator checks.
- Clarified dominance in the SSA terminology (defs must appear on every path to their uses).
- Documented the verifier implementation sketch (input, steps, output) in the DMIR spec.
- Enriched MIR nodes with source locations and wired the verifier to report locations on errors.
- Extended the MIR verifier with partial type tracking (propagating known types, checking calls against known function signatures, return/raise types) while still passing existing tests.
- Added CFG reachability and edge/arg/param/type checks in the MIR verifier (ensuring edge args are defined in source blocks and match dest param types where known).
- Added incoming edge arg/param validation to the MIR verifier to align predecessor args with block params across the CFG.
- Relaxed the MIR call shape to allow optional normal/error edges; updated printer/verifier accordingly to ease initial lowering.
- Added a MIR printer (`lang/mir_printer.py`) and a minimal straight-line lowering path (`lang/lower_to_mir.py`) with a MIR golden test wired into `tests/run_tests.py`.
- Added a minimal MIR→LLVM emitter (`lang/mir_to_llvm.py`) for straight-line functions and a `mir-codegen` just target that lowers `tests/mir_lowering/add.drift` to an object and links/runs it via clang-15/llvmlite.
- Introduced `lang/driftc.py` as a minimal Drift→MIR→LLVM driver (straight-line subset) and moved the MIR codegen harness out of `tools/test-llvm/` into `tests/mir_lowering/`.
- Fixed import shadowing (lang/types vs stdlib types) by adjusting `lang/driftc.py` sys.path handling and invoking it as a module; `just mir-codegen` now runs end-to-end producing and running a native binary.
- Added initial MIR data structures (`lang/mir.py`) to model SSA blocks, instructions, edges, and programs; tests still pass.
- Aligned the String ABI end-to-end: removed the obsolete `lang/_string_runtime_decls.py`, mapped Drift `String` in MIR→LLVM to the runtime struct `{drift_size_t, i8*}`, built string literals as static globals (no heap), and wired string `+` to `drift_string_concat`.
- Made SIZE_T derive from the target data layout (fallback 64-bit) instead of hardcoding i64, and treated an empty String literal as `{0, null}` for clarity; kept forward-declared string runtime helpers ready for future FFI lowering.
- Added console runtime stubs (`drift_console_write/writeln` taking `DriftString` by value), wired MIR with `ConsoleWrite/ConsoleWriteln` instructions, and lowered them in MIR→LLVM via the matching runtime decls.
- Updated the `test` just target to drop linting of the legacy interpreter programs to avoid keeping that folder in sync.
- Temporarily skipped the `runtime_*` codegen cases in `tests/run_tests.py` (they rely on mutation, arrays, full control flow, and module checks not yet supported by the minimal lowering). Also skipped the error/attr/frames cases until the new `String`/`Error` ABI is wired end-to-end. Will re-enable incrementally as features land.
- Reworked the C error runtime to use `DriftString` structs for all text fields/arrays (event, domain, attrs, frames, captures), deep-cloning inputs and freeing via `drift_string_free`. Added LLVM decls in `mir_to_llvm.py` for `drift_error_new`/`error_push_frame` that match the struct-based ABI; codegen still needs to route calls through these.
- Updated MIR→LLVM to resolve `drift_error_new`/`error_push_frame` to the struct-based declarations so the backend uses `%drift.String` everywhere the C runtime expects it.
- Zero-length array lowering now passes `null` pointers to the runtime for `String`/`Int64` arrays instead of GEPs on `[0 x ...]`; fixes GEP-related codegen errors when invoking error helpers.
- Fixed the error ABI mismatch: `drift_error_new`/`error_push_frame` now take pointers to `DriftString` for event/domain/module/file/func, and MIR→LLVM wraps the struct args in allocas before the call. This prevents the garbage `len`/`data` that was crashing `error_path`; `error_path` now passes end-to-end.
- Added implicit return insertion for `Void` functions and renamed generated `main` to `main_drift` to avoid C harness symbol clashes. Unskipped all error/attr/frame codegen cases plus `runtime_basics`; all now pass. Runtime-related codegen tests remain skipped until more language features are lowered.
- Added `ret_type` to MIR `Call` and use the callee’s type when building pair returns; short-circuit `and`/`or` now produce `Bool` phis. Unskipped `runtime_logic` (passes) and kept remaining `runtime_*` tests skipped until the necessary language features are lowered.
- Ensured error helper calls always use the struct-pointer ABI even when the callee was already declared, adjusting arguments accordingly. This fixed the remaining `runtime_functions` codegen failure; the test now passes.
- Implemented array literals and indexed loads for `Array[Int64]` in MIR lowering and MIR→LLVM, with runtime support (`drift_alloc_array`, `drift_bounds_check_fail`) that raises a structured `IndexError`. Unskipped and passed the `runtime_index_bounds` codegen test with the JSON error output.
- Hardened the array runtime: introduced a `drift_size` alias for array metadata, added an overflow/oom guard in `drift_alloc_array`, marked `drift_bounds_check_fail` as `noreturn`, and kept bounds failures returning a structured `IndexError` with exit code 1.
- Added string equality support in the runtime (`drift_string_eq`) and wired MIR→LLVM to lower `String ==/!=` via that helper. This fixes the invalid `icmp` on structs and enables the `runtime_try_catch` codegen test; it now passes and remains unskipped.
- Threaded loop-carried variables through while-block params/edges and relaxed the verifier to allow mutation, eliminating SSA redefinition errors. Unskipped and passed the `runtime_while_basic` codegen test.
- Removed the legacy interpreter and playground artifacts; SSA+LLVM is now the only supported backend. `drift.py` was replaced with a stub error, and runtime files moved under `lang/runtime/`.
- Completed try/catch rework: expression and statement forms support multi-catch and event-based dispatch; binders are scoped correctly; SSA lowering uses a dispatch block with `ErrorEvent` projection. Added e2e and SSA tests for stmt/expr, multi-catch, and event dispatch.
- Implemented reference semantics in SSA: `ReferenceType` mapped to pointers, FieldGet/Set unwrap references, and e2e `ref_struct_mutation` proves mutation through `&mut` across calls.
- Added event-code hashing for exceptions: FQN-based xxHash64 payload, kind/payload layout (4+60 bits), per-module collision checks, and metadata capture. `Error.code` is `I64`; runtime `drift_error_new_dummy` threads code+payload. New SSA/e2e tests cover exception constructors and expr dispatch.
- Introduced runtime C tests for error packing; `just test-runtime-c` builds/runs `runtime_error_dummy_raw` (via `CLANG_BIN`, default clang-15) to assert kind/payload masking over multiple inputs.
- Completed exception args-view + dot-shortcut work: parser/grammar accepts `e.args[.field]`, checker synthesizes ArgKey/ArgsView and key helpers, args-view indexing uses ArgKey and returns `Optional<String>`; lowering constructs the args-view wrapper, extracts key names, and calls `__exc_args_get` backed by the runtime args array (`drift_error_add_arg` populates all fields). Added SSA tests for ArgKey and dot usage plus a negative-key case; runtime test covers the None branch.
- Completed exception args-view + ArgKey integration: runtime `DriftError` holds key/value args with `drift_error_new_dummy` seeding the first arg and `drift_error_add_arg` appending the rest; `__exc_args_get` returns `Optional<String>` ({i8, DriftString}) via ArgKey indexing. Checker synthesizes per-exception ArgKey/ArgsView structs and key helper methods; `e.args` lowers to the synthetic view and ArgKey-based indexing. Added SSA tests for ArgKey lookups and a runtime test for missing args; dot-style usage covered via ArgKey helpers.

## 2025-12-02
- Clarified the exception model in the language spec: all exception arguments and `^`-captured locals are recorded as diagnostic strings in `Error.args` / `ctx_frames`; removed the old “first payload string” wording.
- Introduced a formal `Diagnostic` + `DiagnosticCtx` definition in the traits chapter and marked `Debuggable` as legacy for diagnostics; Chapter 14 now explicitly requires `Diagnostic` for exception fields and captures.
- Updated the exceptions/diagnostics work tracker with a spec-only Step 2 plan; implementation/runtime changes remain out of scope for this pass.
- Hardened dot-shortcut args access: parser now captures `.field` correctly, checker handles `e.args[.foo]` sugar and rejects unknown keys, and the SSA backend fixes the `__exc_args_get` ABI (sret) to stop crashes; added an e2e `exception_args_dot` covering the feature. Added a checker guard that functions may not `return Error`, with a negative SSA test.

## 2025-12-03
- Spec clarifications for struct `val` fields: they are type-level constants with compile-time initializers, excluded from layout/`size_of`, and disallow `Destructible`/non-const types; structs with only `val` fields are ZSTs. Added notes on required vs optional exception-args lookups and renamed `Option` to `Optional` (with a minimal `is_some`/`is_none`/`unwrap_or` API) in the spec.
- Fixed the `__exc_args_get` ABI to use an explicit sret out-param (matching the C runtime) and adjusted SSA codegen to allocate/load the Optional result; this stopped the Optional-path segfaults in `exception_args_optional`.
- SSA simplifier now counts uses across blocks so it no longer drops defs that are only threaded via edges/joins; try/catch lowered programs verify and run again.
- Updated the `captures` e2e expected compile error to the current can-error invariant (“call to can-error function … without error edges”); all e2e/SSA suites are green again.
- Optional as a first-class generic is usable outside exceptions: added `DriftOptionalInt` helpers (`drift_optional_int_some/none`), SSA lowering guards to avoid name clashes in `unwrap_or`, a negative SSA test for bad defaults, and an e2e `optional_basic` that exercises `is_some/is_none/unwrap_or` through SSA→LLVM.
- Added SSA Optional coverage: `optional_phi` exercises Optional<Int> flowing through a branch/join; `optional_phi_type_mismatch` asserts a clean checker error when mixing Optional and non-Optional types across branches.
