// Drift Language Grammar 1.0
// This file defines the surface syntax accepted by the Drift compiler frontend.

// Identifiers: allow leading underscore, but reserve double-underscore (compiler use).
// Give identifiers a lower priority than keyword terminals so the basic lexer
// prefers `and`, `or`, `val`, etc. as their own tokens instead of `NAME`.
NAME.0: /(?!type\b)(?!pub\b)(?!use\b)[A-Za-z][A-Za-z0-9_]*/ | /_[A-Za-z0-9_]*(?<!__)/
%import common.SIGNED_INT
// Float literals: decimal only, digits on both sides of '.', optional exponent.
// Important: float literals never include a leading sign; unary '-' is parsed separately.
FLOAT.2: /[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?/
// String literal with basic escapes plus \xHH hex byte escapes (UTF-8).
STRING: /"(?:[^"\\]|\\["\\ntbrf]|\\x[0-9A-Fa-f]{2})*"/
// f-string prefix: `f` immediately followed by a quote starts an f-string literal.
// This must not steal a standalone identifier named `f`, so we use a lookahead
// that only matches when the next character is the quote.
FSTRING_PREFIX.3: /f(?=\")/
%import common.WS_INLINE

%declare TERMINATOR

SEMI: ";"
NEWLINE: /(\r?\n[ \t]*)/

VAL.2: /val\b/
VAR.2: /var\b/
CONST.2: /const\b/
PUB.2: /pub\b/
USE.2: /use\b/
MUT.2: /mut\b/
TYPE.2: /type\b/
CALL_TYPE_LT.2: /<\s*type\b/
THROW.2: /throw\b/
NOTHROW.2: /nothrow\b/
VARIANT.2: /variant\b/
TOMBSTONE.2: /@tombstone\b/
TEST_BUILD_ONLY.2: /@test_build_only\b/
INTRINSIC.2: /@intrinsic\b/
MATCH.2: /match\b/
DEFAULT.2: /default\b/
# Note: `>>=` must be recognized before `>>` (longest match).
SHR_EQ: ">>="
SHR: ">>"
# Pipeline operator (functional-style staging).
PIPE_FWD: "|>"
# Reserved for future reverse pipeline; no semantics in v1.
PIPE_REV: "<|"
# Note: `<<=` / `<<` must be recognized before `<` / `<=`.
LSHIFT_EQ: "<<="
LSHIFT: "<<"
AND.2: /and\b/
OR.2: /or\b/
EQEQ: "=="
NOTEQ: "!="
IS.2: /is\b/
LTE: "<="
GTE: ">="
LT: "<"
GT: ">"

%declare TYPE_LT TYPE_GT QUAL_TYPE_LT QUAL_TYPE_GT
PLUS: "+"
PLUS_EQ: "+="
MINUS: "-"
MINUS_EQ: "-="
STAR_EQ: "*="
SLASH_EQ: "/="
PERCENT_EQ: "%="
AMP_EQ: "&="
BAR_EQ: "|="
CARET_EQ: "^="
STAR: "*"
SLASH: "/"
PERCENT: "%"
DOT: "."
DCOLON: "::"
COLON: ":"
COMMA: ","
AMP: "&"
BAR: "|"
EQUAL: "="
CARET: "^"
TILDE: "~"
FN_KW.2: /fn\b/
FN_TYPE.2: /Fn\b/
BANG: "!"
IF.2: /if\b/
ELSE.2: /else\b/
WHILE.2: /while\b/
MOVE.2: /move\b/
COPY.2: /copy\b/
CAST.2: /cast\b/
CAPTURES.2: /captures\b/
BREAK.2: /break\b/
CONTINUE.2: /continue\b/
RETHROW.2: /rethrow\b/
ARROW: "->"
FATARROW: "=>"
EXCEPTION.2: /exception\b/
TRAIT.2: /trait\b/
REQUIRE.2: /require\b/
TRY.2: /try\b/
CATCH.2: /catch\b/
EXPORT.2: /export\b/
QMARK: "?"
MODULE.2: /module\b/
LINE_COMMENT: /\/\/[^\n]*/
BLOCK_COMMENT: /\/\*([^*]|\*(?!\/))*\*\//

%ignore WS_INLINE
%ignore NEWLINE
%ignore LINE_COMMENT
%ignore BLOCK_COMMENT

program: (module_decl | item | TERMINATOR)*

module_decl: MODULE module_path
module_path: NAME (DOT NAME)*
ident: NAME | MOVE | COPY

?item: test_build_only_marker? intrinsic_marker? pub_item
     | test_build_only_marker? intrinsic_marker? func_def
     | test_build_only_marker? const_def
     | test_build_only_marker? struct_def
     | test_build_only_marker? exception_def
     | test_build_only_marker? variant_def
     | test_build_only_marker? trait_def
     | test_build_only_marker? implement_def
     | use_trait_stmt TERMINATOR
     | import_stmt TERMINATOR
     | export_stmt TERMINATOR

pub_item: PUB (func_def | const_def | struct_def | exception_def | variant_def | trait_def | implement_def)

# Top-level constant definition.
#
# MVP constraints (enforced by the typed checker):
# - const initializers must be compile-time literals (or unary +/- of a numeric literal),
# - the declared type must match the initializer exactly,
# - consts are values (not types) and may be exported/imported like functions.
const_def: CONST NAME COLON type_expr EQUAL expr TERMINATOR

func_def: FN_KW ident type_params? "(" [params] ")" NOTHROW? return_sig require_clause? (block | TERMINATOR)
return_sig: ARROW type_expr

params: param (COMMA param)*
param: (VAR | VAL)? ident COLON type_expr

# implement Trait for Type { fn ... }
implement_def: "implement" type_params? type_expr ("for" type_expr)? require_clause? implement_body
implement_body: "{" (implement_item | TERMINATOR)* "}"
implement_item: test_build_only_marker? PUB func_def -> implement_func_pub
             | test_build_only_marker? func_def      -> implement_func

trait_def: TRAIT NAME type_params? require_clause? trait_body
trait_body: "{" (trait_item | TERMINATOR)* "}"
trait_item: trait_method_sig TERMINATOR*
trait_method_sig: FN_KW ident type_params? "(" [params] ")" NOTHROW? return_sig

type_expr: ref_type
         | fn_type
         | base_type

fn_type: FN_TYPE "(" [type_expr (COMMA type_expr)*] ")" fn_return
fn_return: NOTHROW? ARROW type_expr
// Function types are not chainable; nesting is always via the return type.

ref_type: AMP MUT? type_expr
// Base (nominal) type reference.
//
// MVP supports a single module-alias qualifier in type positions:
//   import lib as x
//   val p: x.Point = ...
//
// This is *not* a general module path type syntax. Only one dot is allowed
// (alias + name); direct `a.b.c` type paths are deferred.
base_type: NAME DOT NAME type_args? -> qualified_base_type
         | NAME type_args?          -> base_type
type_args: square_type_args
         | angle_type_args
square_type_args: "[" type_expr (COMMA type_expr)* "]"
angle_type_args: ("<" | TYPE_LT) type_expr (COMMA type_expr)* (">" | TYPE_GT)

block: "{" stmt* "}"

// A "value block" is a braced block that evaluates to a value.
// It allows zero or more statements, followed by a trailing expression that
// must not have a terminator.
//
// This is used by expression-form try/catch arms:
//   try foo() catch { log(e); 0 }
value_block: "{" stmt* expr "}"

stmt: compound_stmt
    | simple_stmt TERMINATOR

compound_stmt: if_stmt
             | while_stmt
             | for_stmt
             | try_stmt
             | match_stmt
             | block

simple_stmt: let_stmt
	           | return_stmt
	           | rethrow_stmt
	           | raise_stmt
	           | break_stmt
	           | continue_stmt
	           | aug_assign_stmt
	           | assign_stmt
	           | expr_stmt

// Disambiguation: `try ... catch ...` is both a statement form (`try_stmt`) and
// an expression form (`try_catch_expr`). In statement position we want the
// parser to prefer `try_stmt` so `try foo() catch { ... }` behaves like the
// statement construct (and does not get parsed as an expression statement).
try_stmt.2: TRY (block | expr) catch_clause catch_clause*
catch_clause: CATCH catch_pattern block
catch_pattern: event_fqn "(" ident ")"   -> catch_event
             | ident "(" ident ")"      -> catch_event_unqualified
             | ident                     -> catch_all
             |                          -> catch_all_empty

// Assignments are restricted to lvalue-ish postfix expressions. This also
// prevents `try ... catch ...` from being parsed as the LHS of an assignment,
// which would otherwise interfere with statement-form `try`.
//
// Borrow MVP needs `*p = ...` to support `&mut` writes, so we also allow a
// dereference assignment target.
assign_stmt: assign_target EQUAL expr
aug_assign_stmt: assign_target (PLUS_EQ | MINUS_EQ | STAR_EQ | SLASH_EQ | PERCENT_EQ | AMP_EQ | BAR_EQ | CARET_EQ | LSHIFT_EQ | SHR_EQ) expr
assign_target: postfix
             | STAR assign_target -> deref

for_stmt: "for" ident "in" expr block

if_stmt: IF if_cond block else_clause?
if_cond: trait_expr | expr
else_clause: ELSE block
break_stmt: BREAK
continue_stmt: CONTINUE
while_stmt: WHILE expr block

let_stmt: binder binding_name type_spec? alias_clause? EQUAL expr
binder: VAL
      | VAR
binding_name: capture_marker? ident
capture_marker: CARET
alias_clause: "as" STRING
type_spec: COLON type_expr

require_clause: REQUIRE trait_expr (COMMA trait_expr)*

return_stmt: "return" expr?
rethrow_stmt: RETHROW

raise_stmt: ("raise" domain_clause? expr)
          | (THROW exception_ctor)
          | (THROW expr)

// Expression statements are restricted to postfix expressions (calls, member
// access, indexing, literals, names). This avoids ambiguity with statement-form
// `try` and keeps expression-form `try ... catch ...` as a value-producing
// expression (not a statement).
expr_stmt: postfix

// Module directives (tracked separately from normal statements).
import_stmt: "import" module_path import_alias?
import_alias: "as" NAME

export_stmt: EXPORT "{" export_items? "}"
export_items: export_item (COMMA export_item)*
export_item: NAME | module_path_star
module_path_star: NAME (DOT NAME)* DOT STAR
use_trait_stmt: USE TRAIT trait_ref
trait_ref: module_path

struct_def: "struct" NAME type_params? require_clause? tuple_struct TERMINATOR
          | "struct" NAME type_params? require_clause? block_struct TERMINATOR?
struct_body: tuple_struct | block_struct
tuple_struct: "(" struct_field_list? ")"
struct_field_list: struct_field (COMMA struct_field)*
struct_field: PUB? NAME COLON type_expr
block_struct: "{" TERMINATOR* (block_field TERMINATOR*)* "}"
block_field: struct_field [COMMA]

exception_def: EXCEPTION NAME "(" [exception_params] ")" TERMINATOR?
exception_params: exception_param (COMMA exception_param)*
exception_param: NAME COLON type_expr
                | "domain" EQUAL STRING -> exception_domain_param

domain_clause: "domain" NAME

// Variant (tagged union / sum type).
//
// MVP supports:
// - positional constructor field lists (`Some(value: T, other: U)`),
// - generic type parameters (`variant Optional<T> { ... }`).
variant_def: VARIANT NAME type_params? variant_body TERMINATOR?
type_params: ("<" | TYPE_LT) NAME (COMMA NAME)* (">" | TYPE_GT)
variant_body: "{" (variant_arm (COMMA | TERMINATOR)*)+ "}"
variant_arm: tombstone_marker? NAME variant_fields?
tombstone_marker: TOMBSTONE
test_build_only_marker: TEST_BUILD_ONLY
intrinsic_marker: INTRINSIC
variant_fields: "(" [variant_field_list] ")"
variant_field_list: variant_field (COMMA variant_field)*
variant_field: NAME COLON type_expr

// `expr` is the full expression language (including `try ... catch ...`).
?expr: try_catch_expr
     | match_expr
     | ternary
     | pipeline

// `match` expression and statement forms.
//
// Expression form requires `value_block` arms:
//   match x {
//     Some(v) => { v + 1 },
//     default => { 0 },
//   }
//
// Statement form requires `block` arms only (no `value_block`s).
//
// Notes:
// - arms are comma-separated; trailing comma is allowed.
// - without `default` matches must be exhaustive for known variants.
// - when the match result is used, all arms must provide values and match
//   result types exactly.
match_expr: MATCH expr "{" match_expr_arms "}"
match_stmt: MATCH expr "{" match_stmt_arms "}"
?match_expr_arms: match_expr_arm (COMMA match_expr_arm)* COMMA?
match_expr_arm: match_pat FATARROW match_expr_arm_body
?match_stmt_arms: match_stmt_arm (COMMA match_stmt_arm)* COMMA?
match_stmt_arm: match_pat FATARROW match_stmt_arm_body
match_pat: DEFAULT              -> match_default
         | NAME "(" ")"         -> match_ctor_paren
         | NAME "(" match_named_binders ")"  -> match_ctor_named
         | NAME "(" match_binders ")"  -> match_ctor
         | NAME                  -> match_ctor0
match_binders: NAME (COMMA NAME)*
match_named_binders: match_named_binder (COMMA match_named_binder)*
match_named_binder: NAME EQUAL NAME
match_expr_arm_body: value_block
match_stmt_arm_body: block

// Note: expression-form `try` (`try_catch_expr`) requires catch arms that
// produce a value (see `value_block`). Statement-form `try` (`try_stmt`) uses
// regular blocks.

try_catch_expr.1: TRY expr (CATCH catch_expr_arm)+
catch_expr_arm: event_fqn "(" ident ")" value_block   -> catch_expr_event
              | ident "(" ident ")" value_block       -> catch_expr_event_unqualified
              | ident value_block                     -> catch_expr_binder
              | value_block                          -> catch_expr_block
ternary: pipeline QMARK expr COLON expr

?pipeline: logic_or pipeline_tail*
pipeline_tail: PIPE_FWD logic_or

?logic_or: logic_and logic_or_tail*
logic_or_tail: OR logic_and

?logic_and: bit_or logic_and_tail*
logic_and_tail: AND bit_or

?equality: comparison equality_tail*
equality_tail: (EQEQ | NOTEQ) comparison

?bit_or: bit_xor bit_or_tail*
bit_or_tail: BAR bit_xor

?bit_xor: bit_and bit_xor_tail*
bit_xor_tail: CARET bit_and

?bit_and: equality bit_and_tail*
bit_and_tail: AMP equality

?comparison: shift comparison_tail*
comparison_tail: (LT | LTE | GT | GTE) shift

?shift: sum shift_tail*
shift_tail: (LSHIFT | SHR) sum

?sum: term sum_tail*
sum_tail: (PLUS | MINUS) term

?term: factor term_tail*
term_tail: (STAR | SLASH | PERCENT) factor
?factor: postfix
       | STAR factor -> deref
       | MOVE factor -> move_op
       | COPY factor -> copy_op
       | "+" factor -> pos
       | "-" factor -> neg
       | "not" factor -> not_op
       | BANG factor -> not_op
       | TILDE factor -> bit_not
       | AMP MUT? factor -> borrow

postfix: primary postfix_suffix*
postfix_suffix: call_suffix
              | attr_suffix
              | arrow_suffix
              | index_suffix
              | type_app_suffix
              | qualified_suffix

call_suffix: call_type_args? "(" [call_args] ")"
call_type_args: CALL_TYPE_LT type_expr (COMMA type_expr)* ">"
type_app_suffix: call_type_args
qualified_suffix: qualified_pre_type_args? DCOLON NAME
attr_suffix: DOT NAME
arrow_suffix: ARROW NAME
index_suffix: "[" (leading_dot | expr) "]"

event_fqn: module_path COLON NAME

primary: literal
       | ident -> var
       | leading_dot
       | cast_expr
       | "(" expr ")"
       | lambda_expr
       | array_literal

cast_expr: CAST LT type_expr GT "(" expr ")"

lambda_expr: BAR lambda_params? BAR lambda_captures? lambda_returns? FATARROW lambda_body
lambda_returns: ARROW type_expr
lambda_params: lambda_param (COMMA lambda_param)*
lambda_param: (VAR | VAL)? NAME (COLON type_expr)?
lambda_captures: CAPTURES "(" [lambda_capture_list] ")"
lambda_capture_list: lambda_capture_item (COMMA lambda_capture_item)*
lambda_capture_item: COPY NAME
                   | MOVE NAME
                   | AMP MUT? NAME
                   | NAME

trait_expr: trait_or
trait_or: trait_and (OR trait_and)*
trait_and: trait_not (AND trait_not)*
trait_not: "not" trait_not
         | trait_atom
trait_atom: trait_subject IS trait_name
          | "(" trait_expr ")"
trait_subject: NAME
trait_name: base_type
lambda_body: expr
           | value_block
           | block

// Type-level qualified member reference: `TypeRef::member`.
//
// This is intentionally narrow in MVP: the left-hand side is `base_type`
// (a nominal type reference with optional type arguments), not an arbitrary
// type expression.
//
// Semantics are determined by the typed checker. In MVP, only variant
// constructors are valid members, and the qualified member must be called.
// Qualified type member reference used for variant constructors (MVP).
//
// This is intentionally restricted to avoid ambiguity with existing expression
// syntax (notably module-alias member access and comparisons).
//
// Generic type arguments are supported in a narrowly disambiguated form:
// - `TypeName<T>::Ctor(...)`
// - `TypeName::Ctor<type T>(...)`
//
// The lexer/post-lexer only treats `<...>` as type arguments when the matching
// `>` is followed by an unambiguous commit token (`::` for the pre-`::` form).
// Call-site type args use a `type` marker: `f<type T>(...)`.
qualified_pre_type_args: QUAL_TYPE_LT type_expr (COMMA type_expr)* QUAL_TYPE_GT

qualified_member: NAME qualified_pre_type_args? DCOLON NAME
                | NAME DOT NAME qualified_pre_type_args? DCOLON NAME

leading_dot: DOT NAME leading_suffix*
leading_suffix: call_suffix
              | attr_suffix
              | arrow_suffix
              | index_suffix
              | type_app_suffix

array_literal: "[" [expr (COMMA expr)*] "]"

// Exception constructor call syntax (used only in `throw`).
//
// Design choice:
// - Exceptions are thrown using constructor syntax `throw E(...)` (parens required),
//   not brace initializers. This matches user expectations and keeps `{...}` for
//   struct initializers and map literals.
// - Positional args are allowed and map to declared exception fields by
//   declaration order. Keyword args use `=` and follow the same rule as normal calls:
//   positional arguments must precede keyword arguments.
exception_ctor: event_fqn "(" [call_args] ")"
              | NAME "(" [call_args] ")"

call_args: call_arg (COMMA call_arg)*
call_arg: NAME EQUAL expr -> kwarg
        | expr

literal: FLOAT        -> float_lit
       | SIGNED_INT   -> int_lit
       | STRING       -> str_lit
       | FSTRING_PREFIX STRING -> fstr_lit
       | "true"      -> true_lit
       | "false"     -> false_lit
