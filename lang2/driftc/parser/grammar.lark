// Identifiers: allow leading underscore, but reserve double-underscore (compiler use).
// Give identifiers a lower priority than keyword terminals so the basic lexer
// prefers `and`, `or`, `val`, etc. as their own tokens instead of `NAME`.
NAME.0: /[A-Za-z][A-Za-z0-9_]*/ | /_[A-Za-z0-9_]*(?<!__)/
%import common.SIGNED_INT
// Float literals: decimal only, digits on both sides of '.', optional exponent.
// Important: float literals never include a leading sign; unary '-' is parsed separately.
FLOAT.2: /[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?/
// String literal with basic escapes plus \xHH hex byte escapes (UTF-8).
STRING: /"(?:[^"\\]|\\["\\ntbrf]|\\x[0-9A-Fa-f]{2})*"/
// f-string prefix: `f` immediately followed by a quote starts an f-string literal.
// This must not steal a standalone identifier named `f`, so we use a lookahead
// that only matches when the next character is the quote.
FSTRING_PREFIX.3: /f(?=\")/
%import common.WS_INLINE

%declare TERMINATOR

SEMI: ";"
NEWLINE: /(\r?\n[ \t]*)/

VAL: "val"
VAR: "var"
THROW: "throw"
PIPE: ">>"
AND.2: "&&" | "and"
OR.2: "||" | "or"
EQEQ: "=="
NOTEQ: "!="
LTE: "<="
GTE: ">="
LT: "<"
GT: ">"
PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"
DOT: "."
COLON: ":"
COMMA: ","
AMP: "&"
EQUAL: "="
CARET: "^"
RETURNS: "returns"
BANG: "!"
IF: "if"
ELSE: "else"
WHILE: "while"
BREAK: "break"
CONTINUE: "continue"
RETHROW: "rethrow"
MOVE: "->"
EXCEPTION: "exception"
TRY: "try"
CATCH: "catch"
QMARK: "?"
TERNARY_COLON: ":"
MODULE: "module"
LINE_COMMENT: /\/\/[^\n]*/
BLOCK_COMMENT: /\/\*([^*]|\*(?!\/))*\*\//

%ignore WS_INLINE
%ignore LINE_COMMENT
%ignore BLOCK_COMMENT

program: module_decl? (item | TERMINATOR)*

module_decl: MODULE module_path
module_path: NAME (DOT NAME)*

?item: func_def
     | struct_def
     | exception_def
     | implement_def
     | stmt

func_def: "fn" NAME "(" [params] ")" return_sig block
return_sig: RETURNS type_expr

params: param (COMMA param)*
param: NAME COLON type_expr

# implement Type { fn ... }
implement_def: "implement" type_expr implement_body
implement_body: "{" (implement_item | TERMINATOR)* "}"
implement_item: func_def   -> implement_func

type_expr: ref_type
         | base_type

ref_type: AMP ["mut"] type_expr
base_type: NAME type_args?
type_args: square_type_args
         | angle_type_args
square_type_args: "[" type_expr (COMMA type_expr)* "]"
angle_type_args: "<" type_expr (COMMA type_expr)* ">"

block: "{" (stmt | TERMINATOR)* "}"

// A "value block" is a braced block that evaluates to a value.
// It allows zero or more statements, followed by a trailing expression that
// does not require a terminator (though one may be present).
//
// This is used by expression-form try/catch arms:
//   try foo() catch { log(e); 0 }
value_block: "{" (stmt | TERMINATOR)* expr "}"

stmt: if_stmt
    | try_stmt
    | simple_stmt TERMINATOR

simple_stmt: let_stmt
           | return_stmt
           | rethrow_stmt
           | raise_stmt
           | import_stmt
           | break_stmt
           | continue_stmt
           | while_stmt
           | for_stmt
           | assign_stmt
           | expr_stmt

// Disambiguation: `try ... catch ...` is both a statement form (`try_stmt`) and
// an expression form (`try_catch_expr`). In statement position we want the
// parser to prefer `try_stmt` so `try foo() catch { ... }` behaves like the
// statement construct (and does not get parsed as an expression statement).
try_stmt.2: TRY (block | expr) terminator_opt catch_clause (terminator_opt catch_clause)* terminator_opt
catch_clause: CATCH catch_pattern block
catch_pattern: event_fqn "(" NAME ")"   -> catch_event
             | NAME                     -> catch_all
             |                          -> catch_all_empty

// Assignments are restricted to lvalue-ish postfix expressions. This also
// prevents `try ... catch ...` from being parsed as the LHS of an assignment,
// which would otherwise interfere with statement-form `try`.
assign_stmt: postfix EQUAL expr

for_stmt: "for" NAME "in" expr terminator_opt block

if_stmt: IF expr terminator_opt block else_clause? terminator_opt
else_clause: terminator_opt ELSE terminator_opt block
break_stmt: BREAK
continue_stmt: CONTINUE
while_stmt: WHILE expr terminator_opt block
terminator_opt: TERMINATOR*

let_stmt: binder binding_name type_spec? alias_clause? EQUAL expr
binder: VAL
      | VAR
binding_name: capture_marker? NAME
capture_marker: CARET
alias_clause: "as" STRING
type_spec: COLON type_expr

return_stmt: "return" expr?
rethrow_stmt: RETHROW

raise_stmt: ("raise" domain_clause? expr)
          | (THROW exception_ctor)
          | (THROW expr)

// Expression statements are restricted to postfix expressions (calls, member
// access, indexing, literals, names). This avoids ambiguity with statement-form
// `try` and keeps expression-form `try ... catch ...` as a value-producing
// expression (not a statement).
expr_stmt: postfix

import_stmt: "import" import_path import_alias?
import_path: NAME (DOT NAME)*
import_alias: "as" NAME

struct_def: "struct" NAME struct_body
struct_body: tuple_struct | block_struct
tuple_struct: "(" struct_field_list? ")"
struct_field_list: struct_field (COMMA struct_field)*
struct_field: NAME COLON type_expr
block_struct: "{" TERMINATOR* (block_field TERMINATOR*)* "}"
block_field: struct_field [COMMA]

exception_def: EXCEPTION NAME "(" [exception_params] ")"
exception_params: exception_param (COMMA exception_param)*
exception_param: NAME COLON type_expr
                | "domain" EQUAL STRING -> exception_domain_param

domain_clause: "domain" NAME

// `expr` is the full expression language (including `try ... catch ...`).
?expr: try_catch_expr
     | ternary
     | pipeline

// Note: expression-form `try` (`try_catch_expr`) requires catch arms that
// produce a value (see `value_block`). Statement-form `try` (`try_stmt`) uses
// regular blocks.

try_catch_expr.1: TRY expr (CATCH catch_expr_arm)+
catch_expr_arm: event_fqn "(" NAME ")" value_block   -> catch_expr_event
              | NAME value_block                     -> catch_expr_binder
              | value_block                          -> catch_expr_block
ternary: pipeline QMARK expr TERNARY_COLON expr

?pipeline: logic_or (PIPE logic_or)*

?logic_or: logic_and logic_or_tail*
logic_or_tail: OR logic_and

?logic_and: equality logic_and_tail*
logic_and_tail: AND equality

?equality: comparison equality_tail*
equality_tail: (EQEQ | NOTEQ) comparison

?comparison: sum comparison_tail*
comparison_tail: (LT | LTE | GT | GTE) sum

?sum: term sum_tail*
sum_tail: (PLUS | MINUS) term

?term: factor term_tail*
term_tail: (STAR | SLASH) factor
?factor: postfix
       | "-" factor -> neg
       | "not" factor -> not_op
       | BANG factor -> not_op
       | AMP ["mut"] factor -> borrow

postfix: primary postfix_suffix*
postfix_suffix: call_suffix
              | attr_suffix
              | move_suffix
              | index_suffix

call_suffix: "(" [call_args] ")"
attr_suffix: DOT NAME
move_suffix: MOVE
index_suffix: "[" (leading_dot | expr) "]"

event_fqn: module_path COLON NAME

primary: literal
       | NAME -> var
       | leading_dot
       | "(" expr ")"
       | array_literal

leading_dot: DOT NAME leading_suffix*
leading_suffix: call_suffix
              | attr_suffix
              | move_suffix
              | index_suffix

array_literal: "[" [expr (COMMA expr)*] "]"

exception_ctor: NAME "{" [exception_ctor_field (COMMA exception_ctor_field)*] "}"
exception_ctor_field: NAME EQUAL expr

call_args: call_arg (COMMA call_arg)*
call_arg: NAME EQUAL expr -> kwarg
        | expr

literal: FLOAT        -> float_lit
       | SIGNED_INT   -> int_lit
       | STRING       -> str_lit
       | FSTRING_PREFIX STRING -> fstr_lit
       | "true"      -> true_lit
       | "false"     -> false_lit
