// Drift Language Grammar 1.0
// This file defines the surface syntax accepted by the Drift compiler frontend.

// Identifiers: allow leading underscore, but reserve double-underscore (compiler use).
// Give identifiers a lower priority than keyword terminals so the basic lexer
// prefers `and`, `or`, `val`, etc. as their own tokens instead of `NAME`.
NAME.0: /[A-Za-z][A-Za-z0-9_]*/ | /_[A-Za-z0-9_]*(?<!__)/
%import common.SIGNED_INT
// Float literals: decimal only, digits on both sides of '.', optional exponent.
// Important: float literals never include a leading sign; unary '-' is parsed separately.
FLOAT.2: /[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?/
// String literal with basic escapes plus \xHH hex byte escapes (UTF-8).
STRING: /"(?:[^"\\]|\\["\\ntbrf]|\\x[0-9A-Fa-f]{2})*"/
// f-string prefix: `f` immediately followed by a quote starts an f-string literal.
// This must not steal a standalone identifier named `f`, so we use a lookahead
// that only matches when the next character is the quote.
FSTRING_PREFIX.3: /f(?=\")/
%import common.WS_INLINE

%declare TERMINATOR

SEMI: ";"
NEWLINE: /(\r?\n[ \t]*)/

VAL: "val"
VAR: "var"
CONST: "const"
MUT: "mut"
THROW: "throw"
VARIANT: "variant"
MATCH: "match"
DEFAULT: "default"
# Note: `>>=` must be recognized before `>>` (longest match).
SHR_EQ: ">>="
SHR: ">>"
# Pipeline operator (functional-style staging).
PIPE_FWD: "|>"
# Reserved for future reverse pipeline; no semantics in v1.
PIPE_REV: "<|"
# Note: `<<=` / `<<` must be recognized before `<` / `<=`.
LSHIFT_EQ: "<<="
LSHIFT: "<<"
AND.2: "and"
OR.2: "or"
EQEQ: "=="
NOTEQ: "!="
LTE: "<="
GTE: ">="
LT: "<"
GT: ">"
PLUS: "+"
PLUS_EQ: "+="
MINUS: "-"
MINUS_EQ: "-="
STAR_EQ: "*="
SLASH_EQ: "/="
PERCENT_EQ: "%="
AMP_EQ: "&="
BAR_EQ: "|="
CARET_EQ: "^="
STAR: "*"
SLASH: "/"
PERCENT: "%"
DOT: "."
COLON: ":"
COMMA: ","
AMP: "&"
BAR: "|"
EQUAL: "="
CARET: "^"
TILDE: "~"
RETURNS: "returns"
BANG: "!"
IF: "if"
ELSE: "else"
WHILE: "while"
MOVE: "move"
BREAK: "break"
CONTINUE: "continue"
RETHROW: "rethrow"
ARROW: "->"
FATARROW: "=>"
EXCEPTION: "exception"
TRY: "try"
CATCH: "catch"
EXPORT: "export"
FROM: "from"
QMARK: "?"
MODULE: "module"
LINE_COMMENT: /\/\/[^\n]*/
BLOCK_COMMENT: /\/\*([^*]|\*(?!\/))*\*\//

%ignore WS_INLINE
%ignore LINE_COMMENT
%ignore BLOCK_COMMENT

program: (module_decl | item | TERMINATOR)*

module_decl: MODULE module_path
module_path: NAME (DOT NAME)*
ident: NAME | MOVE

?item: func_def
     | const_def
     | struct_def
     | exception_def
     | variant_def
     | implement_def
     | import_stmt
     | from_import_stmt
     | export_stmt
     | stmt

# Top-level constant definition.
#
# MVP constraints (enforced by the typed checker):
# - const initializers must be compile-time literals (or unary +/- of a numeric literal),
# - the declared type must match the initializer exactly,
# - consts are values (not types) and may be exported/imported like functions.
const_def: CONST NAME COLON type_expr EQUAL expr TERMINATOR

func_def: "fn" ident "(" [params] ")" return_sig block
return_sig: RETURNS type_expr

params: param (COMMA param)*
param: ident COLON type_expr

# implement Type { fn ... }
implement_def: "implement" type_expr implement_body
implement_body: "{" (implement_item | TERMINATOR)* "}"
implement_item: func_def   -> implement_func

type_expr: ref_type
         | base_type

ref_type: AMP MUT? type_expr
// Base (nominal) type reference.
//
// MVP supports a single module-alias qualifier in type positions:
//   import lib as x
//   val p: x.Point = ...
//
// This is *not* a general module path type syntax. Only one dot is allowed
// (alias + name); direct `a.b.c` type paths are deferred.
base_type: NAME DOT NAME type_args? -> qualified_base_type
         | NAME type_args?          -> base_type
type_args: square_type_args
         | angle_type_args
square_type_args: "[" type_expr (COMMA type_expr)* "]"
angle_type_args: "<" type_expr (COMMA type_expr)* ">"

block: "{" (stmt | TERMINATOR)* "}"

// A "value block" is a braced block that evaluates to a value.
// It allows zero or more statements, followed by a trailing expression that
// does not require a terminator (though one may be present).
//
// This is used by expression-form try/catch arms:
//   try foo() catch { log(e); 0 }
value_block: "{" (stmt | TERMINATOR)* expr "}"

stmt: if_stmt
    | try_stmt
    | simple_stmt TERMINATOR

simple_stmt: let_stmt
	           | return_stmt
	           | rethrow_stmt
	           | raise_stmt
	           | break_stmt
	           | continue_stmt
	           | while_stmt
	           | for_stmt
	           | aug_assign_stmt
	           | assign_stmt
	           | expr_stmt

// Disambiguation: `try ... catch ...` is both a statement form (`try_stmt`) and
// an expression form (`try_catch_expr`). In statement position we want the
// parser to prefer `try_stmt` so `try foo() catch { ... }` behaves like the
// statement construct (and does not get parsed as an expression statement).
try_stmt.2: TRY (block | expr) terminator_opt catch_clause (terminator_opt catch_clause)* terminator_opt
catch_clause: CATCH catch_pattern block
catch_pattern: event_fqn "(" ident ")"   -> catch_event
             | ident                     -> catch_all
             |                          -> catch_all_empty

// Assignments are restricted to lvalue-ish postfix expressions. This also
// prevents `try ... catch ...` from being parsed as the LHS of an assignment,
// which would otherwise interfere with statement-form `try`.
//
// Borrow MVP needs `*p = ...` to support `&mut` writes, so we also allow a
// dereference assignment target.
assign_stmt: assign_target EQUAL expr
aug_assign_stmt: assign_target (PLUS_EQ | MINUS_EQ | STAR_EQ | SLASH_EQ | PERCENT_EQ | AMP_EQ | BAR_EQ | CARET_EQ | LSHIFT_EQ | SHR_EQ) expr
assign_target: postfix
             | STAR assign_target -> deref

for_stmt: "for" ident "in" expr terminator_opt block

if_stmt: IF expr terminator_opt block else_clause? terminator_opt
else_clause: terminator_opt ELSE terminator_opt block
break_stmt: BREAK
continue_stmt: CONTINUE
while_stmt: WHILE expr terminator_opt block
terminator_opt: TERMINATOR*

let_stmt: binder binding_name type_spec? alias_clause? EQUAL expr
binder: VAL
      | VAR
binding_name: capture_marker? ident
capture_marker: CARET
alias_clause: "as" STRING
type_spec: COLON type_expr

return_stmt: "return" expr?
rethrow_stmt: RETHROW

raise_stmt: ("raise" domain_clause? expr)
          | (THROW exception_ctor)
          | (THROW expr)

// Expression statements are restricted to postfix expressions (calls, member
// access, indexing, literals, names). This avoids ambiguity with statement-form
// `try` and keeps expression-form `try ... catch ...` as a value-producing
// expression (not a statement).
expr_stmt: postfix

// Module directives (tracked separately from normal statements).
import_stmt: "import" module_path import_alias?
import_alias: "as" NAME

from_import_stmt: FROM module_path "import" (STAR | NAME) import_alias?

export_stmt: EXPORT "{" export_items? "}"
export_items: NAME (COMMA NAME)*

struct_def: "struct" NAME struct_body
struct_body: tuple_struct | block_struct
tuple_struct: "(" struct_field_list? ")"
struct_field_list: struct_field (COMMA struct_field)*
struct_field: NAME COLON type_expr
block_struct: "{" TERMINATOR* (block_field TERMINATOR*)* "}"
block_field: struct_field [COMMA]

exception_def: EXCEPTION NAME "(" [exception_params] ")"
exception_params: exception_param (COMMA exception_param)*
exception_param: NAME COLON type_expr
                | "domain" EQUAL STRING -> exception_domain_param

domain_clause: "domain" NAME

// Variant (tagged union / sum type).
//
// MVP supports:
// - positional constructor field lists (`Some(value: T, other: U)`),
// - generic type parameters (`variant Optional<T> { ... }`).
variant_def: VARIANT NAME type_params? variant_body
type_params: "<" NAME (COMMA NAME)* ">"
variant_body: "{" (variant_arm (COMMA | TERMINATOR)*)+ "}"
variant_arm: NAME variant_fields?
variant_fields: "(" [variant_field_list] ")"
variant_field_list: variant_field (COMMA variant_field)*
variant_field: NAME COLON type_expr

// `expr` is the full expression language (including `try ... catch ...`).
?expr: try_catch_expr
     | match_expr
     | ternary
     | pipeline

// `match` expression (expression-only in MVP). Each arm body is a block:
//   match x {
//     Some(v) => { v + 1 }
//     default => { 0 }
//   }
//
// Arm bodies use:
// - `value_block` when the arm produces a value, and
// - `block` when the match result is unused (statement position).
//
// Type checking enforces:
// - `default` (if present) is last and appears at most once,
// - duplicates are rejected,
// - without `default` matches must be exhaustive for known variants, and
// - when the match result is used, all arms must provide `value_block`s whose
//   result types match exactly.
match_expr: MATCH expr "{" (match_arm (TERMINATOR | COMMA)*)+ "}"
match_arm: match_pat FATARROW match_arm_body
match_pat: DEFAULT              -> match_default
         | NAME "(" [match_binders] ")"  -> match_ctor
         | NAME                  -> match_ctor0
match_binders: NAME (COMMA NAME)*
match_arm_body: value_block
              | block

// Note: expression-form `try` (`try_catch_expr`) requires catch arms that
// produce a value (see `value_block`). Statement-form `try` (`try_stmt`) uses
// regular blocks.

try_catch_expr.1: TRY expr (CATCH catch_expr_arm)+
catch_expr_arm: event_fqn "(" ident ")" value_block   -> catch_expr_event
              | ident value_block                     -> catch_expr_binder
              | value_block                          -> catch_expr_block
ternary: pipeline QMARK expr COLON expr

?pipeline: logic_or pipeline_tail*
pipeline_tail: PIPE_FWD logic_or

?logic_or: logic_and logic_or_tail*
logic_or_tail: OR logic_and

?logic_and: bit_or logic_and_tail*
logic_and_tail: AND bit_or

?equality: comparison equality_tail*
equality_tail: (EQEQ | NOTEQ) comparison

?bit_or: bit_xor bit_or_tail*
bit_or_tail: BAR bit_xor

?bit_xor: bit_and bit_xor_tail*
bit_xor_tail: CARET bit_and

?bit_and: equality bit_and_tail*
bit_and_tail: AMP equality

?comparison: shift comparison_tail*
comparison_tail: (LT | LTE | GT | GTE) shift

?shift: sum shift_tail*
shift_tail: (LSHIFT | SHR) sum

?sum: term sum_tail*
sum_tail: (PLUS | MINUS) term

?term: factor term_tail*
term_tail: (STAR | SLASH | PERCENT) factor
?factor: postfix
       | STAR factor -> deref
       | MOVE factor -> move_op
       | "-" factor -> neg
       | "not" factor -> not_op
       | BANG factor -> not_op
       | TILDE factor -> bit_not
       | AMP MUT? factor -> borrow

postfix: primary postfix_suffix*
postfix_suffix: call_suffix
              | attr_suffix
              | arrow_suffix
              | index_suffix

call_suffix: "(" [call_args] ")"
attr_suffix: DOT NAME
arrow_suffix: ARROW NAME
index_suffix: "[" (leading_dot | expr) "]"

event_fqn: module_path COLON NAME

primary: literal
       | ident -> var
       | leading_dot
       | "(" expr ")"
       | array_literal

leading_dot: DOT NAME leading_suffix*
leading_suffix: call_suffix
              | attr_suffix
              | arrow_suffix
              | index_suffix

array_literal: "[" [expr (COMMA expr)*] "]"

// Exception constructor call syntax (used only in `throw`).
//
// Design choice:
// - Exceptions are thrown using constructor syntax `throw E(...)` (parens required),
//   not brace initializers. This matches user expectations and keeps `{...}` for
//   struct initializers and map literals.
// - Positional args are allowed and map to declared exception fields by
//   declaration order. Keyword args use `=` and follow the same rule as normal calls:
//   positional arguments must precede keyword arguments.
exception_ctor: NAME "(" [call_args] ")"

call_args: call_arg (COMMA call_arg)*
call_arg: NAME EQUAL expr -> kwarg
        | expr

literal: FLOAT        -> float_lit
       | SIGNED_INT   -> int_lit
       | STRING       -> str_lit
       | FSTRING_PREFIX STRING -> fstr_lit
       | "true"      -> true_lit
       | "false"     -> false_lit
