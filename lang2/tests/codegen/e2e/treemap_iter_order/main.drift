module main

import std.containers as containers;
import std.iter as iter;
use trait iter.SinglePassIterator;

fn run() -> Int {
	var m = containers.tree_map<type Int, Int>();
	m.insert(5, 50);
	m.insert(3, 30);
	m.insert(7, 70);
	m.insert(2, 20);
	m.insert(4, 40);
	m.insert(6, 60);
	m.insert(8, 80);
	val expected = [2, 3, 4, 5, 6, 7, 8];
	var it = m.iter();
	var idx = 0;
	var done = false;
	while not done {
		val nxt = it.next();
		match nxt {
			None => { done = true; },
			Some(item) => {
				if idx >= expected.len {
					return 1;
				}
				val want = expected[idx];
				if *item.key != want {
					return 2;
				}
				idx = idx + 1;
			}
		}
	}
	if idx != expected.len {
		return 3;
	}
	val k3 = 3;
	val k7 = 7;
	val _r1 = m.remove(&k3);
	val _r2 = m.remove(&k7);
	m.insert(1, 10);
	m.insert(9, 90);
	val expected2 = [1, 2, 4, 5, 6, 8, 9];
	var it2 = m.iter();
	var idx2 = 0;
	var done2 = false;
	while not done2 {
		val nxt2 = it2.next();
		match nxt2 {
			None => { done2 = true; },
			Some(item) => {
				if idx2 >= expected2.len {
					return 4;
				}
				val want2 = expected2[idx2];
				if *item.key != want2 {
					return 5;
				}
				idx2 = idx2 + 1;
			}
		}
	}
	if idx2 != expected2.len {
		return 6;
	}
	return 0;
}

fn main() nothrow -> Int {
	return try run() catch { 99 };
}
