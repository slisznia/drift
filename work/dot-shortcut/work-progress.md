## Overview

This workstream enhances Drift exceptions so that:

* Exceptions support **any number of arguments**, each of arbitrary type.
* All arguments undergo **diagnostic formatting**, not `Display`.
* Args and `^` locals are stored as **diagnostic strings** (no “first payload” special case).
* Catch-time access uses **typed keys** instead of stringly lookup.
* **Dot-shortcut** sugar improves ergonomic, type-safe access to exception argument keys.

This file tracks work across three steps:

* **Step 1 — Spec cleanup** *(complete)*
* **Step 2 — Diagnostic trait formalization** *(complete)*
* **Step 3 — Key-indexing & dot-shortcut sugar** *(spec/grammar done; compiler/runtime next)*

---

## Step 1 — Spec cleanup (complete)

**Goal:** Clean up the existing exception sections to:

* remove legacy “payload” / “first arg” behavior,
* normalize all exception arguments and captured locals to `Diagnostic`/`String`,
* clarify catch-time semantics (matching by event code, not payload type),
* introduce the eventual args-view/key vocabulary.

This is a **spec-only** step; no compiler/runtime changes are expected here beyond keeping the spec in sync with current behavior.

### 1.1. Remove the “first payload” special case

**Status:** done.

* The old model treated one exception arg as a special “payload” and others as secondary.
* The new model treats **all** args uniformly: each arg is a named value that’s converted to a diagnostic string.

Spec changes:

* Chapter 14 rewritten to remove “first payload” special case.
* All exception args and `^` locals must implement **Diagnostic**; normalized to `String`.
* Catch semantics clarified: event dispatch by name; no payload typing.
* `Error.args` defined as `Map<String, String>`.
* Updated wording in try/catch sections to match diagnostic-only model.
* Step recorded as spec-only, no code/tests.

### Status: **DONE**

---

## Step 2 — Diagnostic trait (spec-only) (complete)

**Goal:** Introduce the dedicated trait that produces structured diagnostic strings.

This step is about the **trait** and its role in exceptions; actual trait resolution and codegen are still covered by other workstreams.

### 2.1. Define Diagnostic

**Status:** done.

Spec elements:

* New trait:

  ```drift
  trait Diagnostic {
      fn to_diagnostic(self) returns String
  }
````

* `String` implements `Diagnostic` as identity.
* Primitive types (`Int`, `Bool`, etc.) and common standard types (`Array<T>`, `Option<T>`, `Result<T, E>`, etc.) must eventually implement `Diagnostic` in the standard library, but that’s not enforced by this workstream.

### 2.2. Exception args and locals use Diagnostic

**Status:** done.

Spec changes:

* All exception arguments and captured locals (`^foo`) are converted with `to_diagnostic` and stored as `String`s.

* The exception object holds:

  ```drift
  event_code: Int
  args: Map<String, String>
  locals: Map<String, String>  // optional / future
  ```

* The `Error` type exposes this diagnostic data abstractly; no commit here to the exact internal layout.

### 2.3. Catch-time semantics clarified

**Status:** done.

* Catch dispatch is based on **event codes** (name + domain hashing), not payload or arg types.
* Catch clauses may pattern on the exception **name** and optionally bind a typed local `e: Error`.
* Args and locals are available via a **diagnostic view**, not through typed fields.

### Status: **DONE**

---

## Step 3 — Key-indexing & dot-shortcut sugar

**Goal:** Provide a type-safe, ergonomic way to access exception arguments and captured locals:

* A per-exception **args-view** type (e.g., `MyErrorArgsView`) that wraps `Error` and provides methods for known keys.
* Per-exception **arg-key** types (e.g., `MyErrorArgKey`) that represent field keys in a way the type system can reason about.
* `Option<String>`-based lookup (`view[key] -> Option<String>`) backed by the runtime args map.
* **Dot-shortcut** syntax (`e.args[.field]`) that desugars to the typed key/API.

This step is split into three sub-steps:

* **3A — Spec & grammar** *(done, with later grammar TODO for leading-dot)*
* **3B — Compiler + runtime plumbing** *(implemented; leading-dot grammar still pending)*
* **3C — Catch-all/generic Error behavior** *(future)*

---

### Step 3A — Spec & grammar (done)

This is the design foundation for args-views, arg-keys, and dot-shortcut. Implementation lives in 3B; generic Error behavior in 3C.

#### 3A.1. Per-exception arg-view and key types

For each exception:

```drift
exception MyError(a: String, b: String)
```

we conceptually define two synthetic types:

```drift
struct MyErrorArgKey {
    name: String
}

struct MyErrorArgsView {
    error: Error
}
```

and make sure they’re visible to the type system.

These types are **not** user-written; they’re generated by the compiler and behave like ordinary structs (for field access, etc.), but:

* Their layout is known to the compiler.
* Their methods are generated, not written by the user.

#### 3A.2. Methods on the args-view

For each declared field, we attach a method on `MyErrorArgsView`:

```drift
implement MyErrorArgsView {
    fn a(self) returns MyErrorArgKey
    fn b(self) returns MyErrorArgKey
}
```

These methods are pure key constructors:

* They take the view (or a reference) and return a **key value** tied to `MyError`.
* Internally, they simply carry the field name as a string (`"a"` / `"b"`) in the `MyErrorArgKey.name` field.

The spec doesn’t commit to the exact syntax (`fn a(self: &MyErrorArgsView)` vs value receiver) beyond the type-level contract:

* `MyErrorArgsView.a() : MyErrorArgKey`
* `MyErrorArgsView.b() : MyErrorArgKey`

#### 3A.3. Args-view indexing

We define an indexing operation on `MyErrorArgsView`:

```drift
fn operator[](view: MyErrorArgsView, key: MyErrorArgKey) returns Option<String>
```

Semantics:

* The `key` determines which argument to look up by its `name`.
* The return is `Option<String>`:

  * `Some(value)` if the arg with that name exists.
  * `None` if the arg is not present (e.g., future partial construction cases).

The spec assumes this is backed by the runtime `args: Map<String, String>` (or equivalent) on `Error`.

#### 3A.4. Dot-shortcut syntax (design)

We design a syntactic sugar:

```drift
e.args[.a]
e.args[.b]
```

for:

```drift
let view = e.args
view[view.a()]
view[view.b()]
```

Key points:

* The expression `e.args` yields `MyErrorArgsView` when `e` is a `MyError` in a typed catch.
* `view.a()` returns `MyErrorArgKey`.
* `view[view.a()]` returns `Option<String>`.

The **leading-dot** syntax (`.a`) is **pure sugar** that:

* Names a specific arg-key tied to the args-view on the left of `[]`.
* Is intended to be implemented at the parser/AST level later (see Step 3B status and TODO).

#### 3A.5. Catch-time access

Inside a typed catch:

```drift
try {
    ...
} catch MyError(e) {
    val a = e.args[.a].unwrap()
    val b_len = e.args[.b].map(fn (s) => s.len()).unwrap_or(0)
}
```

Specifically:

* `e` has type `Error` in the surface language, but the catch clause statically knows it’s `MyError`.
* `e.args` is treated as `MyErrorArgsView` in this scope.
* `e.args[.a]` is `Option<String>`; `unwrap()` is allowed to be used for “must exist” scenarios.

This is still typed and desugared as:

```drift
let view = e.args     // MyErrorArgsView
let a_key = view.a()  // MyErrorArgKey
val a = view[a_key].unwrap()
```

#### 3A.6. Generic Error behavior (design-only)

For untyped catches (`catch (e)` or `catch Error(e)`):

* The spec continues to allow a more generic, stringly API:

  ```drift
  val code = e.args().key("sql_state").first().unwrap_or("<none>");
  ```

* This workstream **does not** change the generic `Error` API yet.

* Typed args-views are a feature of typed catches, not the generic `Error`.

---

### Step 3B — Compiler + runtime plumbing

This is the implementation of:

* Arg schema emission from the checker.
* Synthetic `ArgKey` / `ArgsView` types.
* `e.args` lowering to an args-view struct.
* Key helper methods and ArgKey-based indexing.
* Runtime backing (`DriftError.args`, `drift_error_new_dummy`, `drift_error_add_arg`, `__exc_args_get`).
* Dot-shortcut desugaring (when grammar catches up).

#### 3B.1. Exception metadata & event codes

**Status:** done.

Compiler work:

* `Checker._register_exceptions` now computes:

  * `arg_order: List[String]` in declaration order.
  * `arg_types: Map[String, Type]`.
  * `event_code: Int` (kind + payload60) used by the runtime.
  * `ExceptionMeta` entries that include `event_code` and `arg_order`.

* The metadata is used later to:

  * Synthesize `<Exc>ArgKey` and `<Exc>ArgsView` types.
  * Drive runtime args table construction.
  * Type-check args-view operations against the declared schema.

Runtime work (relevant to 3B.1):

* `DriftError` struct extended to carry a pointer and count for args:

  ```c
  struct DriftErrorArg {
      DriftString key;
      DriftString value;
  };

  struct DriftError {
      int64_t code;
      DriftString payload;
      struct DriftErrorArg *args;
      size_t arg_count;
  };
  ```

* `drift_error_new_dummy(uint64_t event_code, DriftString key, DriftString payload)`:

  * Stores `event_code` as-is in `code`.
  * Seeds `args` with a single `(key, payload)` pair when `key.len > 0`.
  * Leaves `args == NULL` and `arg_count == 0` when `key` is empty.

* `drift_error_get_arg(const DriftError *err, DriftString key) -> const DriftString *`:

  * Iterates `args[0..arg_count)` to find a matching key.
  * Returns pointer to `value` on hit, `NULL` on miss.

#### 3B.2. Synthetic ArgKey / ArgsView types

**Status:** done.

Compiler work:

* Introduced `StructInfo.is_synthetic` to distinguish synthetic from user structs.

* Added `_define_struct(name, field_types, is_synthetic)` helper in the checker:

  * Defines a struct in `struct_infos`.
  * Registers a constructor signature in `function_infos`.
  * Returns the created `StructInfo`.

* `_register_exceptions` now:

  * Synthesizes `MyErrorArgKey`:

    ```drift
    struct MyErrorArgKey { name: String }
    ```

  * Synthesizes `MyErrorArgsView`:

    ```drift
    struct MyErrorArgsView { error: Error }
    ```

  * Stores the corresponding `StructInfo`s on `ExceptionInfo.arg_key_struct` / `.args_view_struct`.

  * Records the type names in `ExceptionInfo.arg_key_type` / `.args_view_type`.

Type-checking:

* `MyErrorArgsView` is a normal struct type with a single `error: Error` field.
* `MyErrorArgKey` is a normal struct type with a single `name: String` field.
* Both participate in lookup, field access, etc., as regular structs.

#### 3B.3. Compiler-driven key helpers (methods)

**Status:** done.

Compiler work:

* `StructInfo` now tracks `methods: Map[String, FunctionSignature]` for synthetic methods.

* `_register_exceptions` populates, for each `MyErrorArgsView`, methods:

  ```drift
  fn a(self: MyErrorArgsView) returns MyErrorArgKey
  fn b(self: MyErrorArgsView) returns MyErrorArgKey
  ```

* These are stored as `FunctionSignature`s only; their bodies are synthesized in lowering.

Checker work:

* `_resolve_attr_type`:

  * For struct types, checks `struct_info.methods` first:

    * `view.a` → return type `MyErrorArgKey`.
    * `view.b` → return type `MyErrorArgKey`.

* `_resolve_callee` recognizes method calls:

  * `view.a()` resolves to the method `MyErrorArgsView.a`.
  * `_check_call` enforces the synthetic signature (no args, correct receiver).

Lowering work:

* When encountering `view.a()` or `view.b()`:

  * Lowering doesn’t emit a real function call.

  * Instead, it synthesizes a `MyErrorArgKey` struct value:

    ```drift
    MyErrorArgKey(name = "a")
    ```

  * In MIR/SSA, this is a `StructInit` with the field `name` set to a string literal.

#### 3B.4. ExceptionCtor lowering and arg population

**Status:** done (for String-typed args).

Compiler/runtime work:

* `ExceptionCtor` now carries `arg_order` in the AST, preserving the original field order.
* Lowering does:

  * Picks the first field in `arg_order` (if any) as the dummy ctor seed:

    ```drift
    drift_error_new_dummy(event_code, first_key, first_value)
    ```

  * Obtains the returned `Error*` and uses it for subsequent arg additions.

  * For each remaining field `(key, value)` in `arg_order[1:]`:

    ```drift
    drift_error_add_arg(err, key, value)
    ```

Runtime work:

* `drift_error_add_arg(Error *err, DriftString key, DriftString value)`:

  * Reallocates `err->args` to append one more `DriftErrorArg`.
  * Copies `key` and `value` into the new slot.
  * Increments `arg_count`.

Constraint (current implementation):

* Only `String`-typed args are wired into this path so far; non-String args must be formatted to `String` at the checker/IR level before being passed into the ctor/add functions (this is consistent with the “Diagnostic → String” model).

#### 3B.5. Args-view and ArgKey lookup → Option<String>

**Status:** done.

Runtime work:

* Added `DriftOptionString`:

  ```c
  struct DriftOptionString {
      uint8_t is_some;
      struct DriftString value;
  };
  ```

* Added `__exc_args_get(const DriftError *err, DriftString key)`:

  * Calls `drift_error_get_arg(err, key)`.
  * On hit: returns `{ .is_some = 1, .value = *val }`.
  * On miss: returns `{ .is_some = 0, .value = empty_string }`.

Compiler work:

* In `lang/runtime/__init__.py`, registered the builtin signature:

  ```python
  "__exc_args_get": FunctionSignature(
      "__exc_args_get",
      (ERROR, STR),
      Type("Option", args=(STR,)),
      effects=None,
  )
  ```

* SSA/LLVM:

  * `_llvm_type_with_structs(Type("Option", (STR,)))` → `{ i8, DriftString }`, matching `DriftOptionString`.
  * The call site for `__exc_args_get` uses:

    ```llvm
    %res = call { i8, %drift.String } @__exc_args_get(%Error* %err, %drift.String %key)
    ```

Lowering work:

* Args-view indexing (`view[key]`) is recognized by a helper `_maybe_lower_args_view_index`:

  * Lowers the base expression `view`:

    * Confirms its type is a synthetic args-view struct with an `error: Error` field.

  * Lowers the index expression `key`:

    * Confirms its type is the matching `MyErrorArgKey` struct with a `name: String` field.

  * Extracts:

    * `err` via `FieldGet(view, "error")`.
    * `key_name` via `FieldGet(key, "name")`.

  * Emits `Call __exc_args_get(err, key_name)` with result type `Option<String>`.

Checker work:

* `_check_index_expr`:

  * For args-view types:

    * Requires the index type to be `Type(exc.arg_key_type)` (`MyErrorArgKey`).
    * Returns `Type("Option", (STR,))` — i.e., `Option<String>`.

  * For all other containers, falls back to the existing array indexing rule (`Int` index).

#### 3B.6. e.args → args-view

**Status:** done.

Compiler work:

* In typed catches:

  ```drift
  catch MyError(e) {
      e.args
  }
  ```

  is treated as `MyErrorArgsView`.

* Lowering:

  * `e` is lowered to an `Error` SSA value.
  * `e.args` is lowered to a `MyErrorArgsView` struct with:

    ```drift
    MyErrorArgsView(error = e)
    ```

This is the base expression used for both:

* Explicit key-helper usage: `view[view.a()]`.
* Future dot-shortcut usage: `e.args[.a]` (once grammar is added).

#### 3B.7. Tests

**Status:** done.

Runtime tests:

* `tests/runtime_error_dummy_raw.c`:

  * Confirms that `drift_error_new_dummy` preserves the full event code and seeds the args array correctly.

* `tests/runtime_error_args_none.c`:

  * Constructs an error with known args.
  * Calls `__exc_args_get` with a missing key.
  * Asserts `is_some == 0` (None path).

SSA/e2e tests:

* `tests/ssa_programs/exception_args_lookup.drift`:

  * Throws `MyError(a = "AA", b = "BBB")`.

  * In the catch:

    ```drift
    let view = e.args
    let ka = view.a()
    let kb = view.b()
    let la = view[ka].unwrap().len()
    let lb = view[kb].unwrap().len()
    ```

  * Asserts the sum of lengths (happy path through `Option<String>` and `__exc_args_get`).

* `tests/ssa_programs/exception_args_dot_lookup.drift`:

  * Same scenario, but exercises the key helper form explicitly:

    ```drift
    let view = e.args
    let la = view[view.a()].unwrap().len()
    let lb = view[view.b()].unwrap().len()
    ```

  * This is currently the stand-in for dot-shortcut until the grammar supports leading-dot.

---

### Step 3B Status

* **Spec/grammar:** design done; parser **does not yet** implement leading-dot `e.args[.field]` sugar. Tests currently use the explicit key-helper form `view[view.a()]` instead.
* **Compiler/runtime:**

  * Checker emits per-exception arg schema (`event_code`, `arg_order`, `arg_types`).
  * Synthetic `<Exc>ArgKey` / `<Exc>ArgsView` structs are generated and registered.
  * `e.args` materializes the per-exception args-view struct (`{ error: Error }`).
  * Per-field key helpers (`a()`, `b()`, …) are synthesized on the args-view type and return `<Exc>ArgKey`.
  * Args-view indexing `view[key]` expects `<Exc>ArgKey` and returns `Option<String>`, lowering to `__exc_args_get` backed by `DriftError.args` + `drift_error_add_arg`.
  * Runtime helpers `drift_error_new_dummy`, `drift_error_add_arg`, and `__exc_args_get` are implemented and covered by runtime tests (Some/None paths).

* Once grammar is updated, re-enable `e.args[.field]` SSA tests as the primary dot-shortcut example; keep the key-helper form as a supported alternative.

## Overview

This workstream enhances Drift exceptions so that:

* Exceptions support **any number of arguments**, each of arbitrary type.
* All arguments undergo **diagnostic formatting**, not `Display`.
* Args and `^` locals are stored as **diagnostic strings** (no “first payload” special case).
* Catch-time access uses **typed keys** instead of stringly lookup.
* **Dot-shortcut** sugar improves ergonomic, type-safe access to exception argument keys.

This file tracks work across three steps:

* **Step 1 — Spec cleanup** *(complete)*
* **Step 2 — Diagnostic trait formalization** *(complete)*
* **Step 3 — Key-indexing & dot-shortcut sugar** *(spec/grammar done; compiler/runtime next)*

---

## Step 1 — Spec cleanup (complete)

**Goal:** Clean up the existing exception sections to:

* remove legacy “payload” / “first arg” behavior,
* normalize all exception arguments and captured locals to `Diagnostic`/`String`,
* clarify catch-time semantics (matching by event code, not payload type),
* introduce the eventual args-view/key vocabulary.

This is a **spec-only** step; no compiler/runtime changes are expected here beyond keeping the spec in sync with current behavior.

### 1.1. Remove the “first payload” special case

**Status:** done.

* The old model treated one exception arg as a special “payload” and others as secondary.
* The new model treats **all** args uniformly: each arg is a named value that’s converted to a diagnostic string.

Spec changes:

* Chapter 14 rewritten to remove “first payload” special case.
* All exception args and `^` locals must implement **Diagnostic**; normalized to `String`.
* Catch semantics clarified: event dispatch by name; no payload typing.
* `Error.args` defined as `Map<String, String>`.
* Updated wording in try/catch sections to match diagnostic-only model.
* Step recorded as spec-only, no code/tests.

### Status: **DONE**

---

## Step 2 — Diagnostic trait (spec-only) (complete)

**Goal:** Introduce the dedicated trait that produces structured diagnostic strings.

This step is about the **trait** and its role in exceptions; actual trait resolution and codegen are still covered by other workstreams.

### 2.1. Define Diagnostic

**Status:** done.

Spec elements:

* New trait:

  ```drift
  trait Diagnostic {
      fn to_diagnostic(self) returns String
  }
````

* `String` implements `Diagnostic` as identity.
* Primitive types (`Int`, `Bool`, etc.) and common standard types (`Array<T>`, `Option<T>`, `Result<T, E>`, etc.) must eventually implement `Diagnostic` in the standard library, but that’s not enforced by this workstream.

### 2.2. Exception args and locals use Diagnostic

**Status:** done.

Spec changes:

* All exception arguments and captured locals (`^foo`) are converted with `to_diagnostic` and stored as `String`s.

* The exception object holds:

  ```drift
  event_code: Int
  args: Map<String, String>
  locals: Map<String, String>  // optional / future
  ```

* The `Error` type exposes this diagnostic data abstractly; no commit here to the exact internal layout.

### 2.3. Catch-time semantics clarified

**Status:** done.

* Catch dispatch is based on **event codes** (name + domain hashing), not payload or arg types.
* Catch clauses may pattern on the exception **name** and optionally bind a typed local `e: Error`.
* Args and locals are available via a **diagnostic view**, not through typed fields.

### Status: **DONE**

---

## Step 3 — Key-indexing & dot-shortcut sugar

**Goal:** Provide a type-safe, ergonomic way to access exception arguments and captured locals:

* A per-exception **args-view** type (e.g., `MyErrorArgsView`) that wraps `Error` and provides methods for known keys.
* Per-exception **arg-key** types (e.g., `MyErrorArgKey`) that represent field keys in a way the type system can reason about.
* `Option<String>`-based lookup (`view[key] -> Option<String>`) backed by the runtime args map.
* **Dot-shortcut** syntax (`e.args[.field]`) that desugars to the typed key/API.

This step is split into three sub-steps:

* **3A — Spec & grammar** *(done, with later grammar TODO for leading-dot)*
* **3B — Compiler + runtime plumbing** *(implemented; leading-dot grammar still pending)*
* **3C — Catch-all/generic Error behavior** *(future)*

---

### Step 3A — Spec & grammar (done)

This is the design foundation for args-views, arg-keys, and dot-shortcut. Implementation lives in 3B; generic Error behavior in 3C.

#### 3A.1. Per-exception arg-view and key types

For each exception:

```drift
exception MyError(a: String, b: String)
```

we conceptually define two synthetic types:

```drift
struct MyErrorArgKey {
    name: String
}

struct MyErrorArgsView {
    error: Error
}
```

and make sure they’re visible to the type system.

These types are **not** user-written; they’re generated by the compiler and behave like ordinary structs (for field access, etc.), but:

* Their layout is known to the compiler.
* Their methods are generated, not written by the user.

#### 3A.2. Methods on the args-view

For each declared field, we attach a method on `MyErrorArgsView`:

```drift
implement MyErrorArgsView {
    fn a(self) returns MyErrorArgKey
    fn b(self) returns MyErrorArgKey
}
```

These methods are pure key constructors:

* They take the view (or a reference) and return a **key value** tied to `MyError`.
* Internally, they simply carry the field name as a string (`"a"` / `"b"`) in the `MyErrorArgKey.name` field.

The spec doesn’t commit to the exact syntax (`fn a(self: &MyErrorArgsView)` vs value receiver) beyond the type-level contract:

* `MyErrorArgsView.a() : MyErrorArgKey`
* `MyErrorArgsView.b() : MyErrorArgKey`

#### 3A.3. Args-view indexing

We define an indexing operation on `MyErrorArgsView`:

```drift
fn operator[](view: MyErrorArgsView, key: MyErrorArgKey) returns Option<String>
```

Semantics:

* The `key` determines which argument to look up by its `name`.
* The return is `Option<String>`:

  * `Some(value)` if the arg with that name exists.
  * `None` if the arg is not present (e.g., future partial construction cases).

The spec assumes this is backed by the runtime `args: Map<String, String>` (or equivalent) on `Error`.

#### 3A.4. Dot-shortcut syntax (design)

We design a syntactic sugar:

```drift
e.args[.a]
e.args[.b]
```

for:

```drift
let view = e.args
view[view.a()]
view[view.b()]
```

Key points:

* The expression `e.args` yields `MyErrorArgsView` when `e` is a `MyError` in a typed catch.
* `view.a()` returns `MyErrorArgKey`.
* `view[view.a()]` returns `Option<String>`.

The **leading-dot** syntax (`.a`) is **pure sugar** that:

* Names a specific arg-key tied to the args-view on the left of `[]`.
* Is intended to be implemented at the parser/AST level later (see Step 3B status and TODO).

#### 3A.5. Catch-time access

Inside a typed catch:

```drift
try {
    ...
} catch MyError(e) {
    val a = e.args[.a].unwrap()
    val b_len = e.args[.b].map(fn (s) => s.len()).unwrap_or(0)
}
```

Specifically:

* `e` has type `Error` in the surface language, but the catch clause statically knows it’s `MyError`.
* `e.args` is treated as `MyErrorArgsView` in this scope.
* `e.args[.a]` is `Option<String>`; `unwrap()` is allowed to be used for “must exist” scenarios.

This is still typed and desugared as:

```drift
let view = e.args     // MyErrorArgsView
let a_key = view.a()  // MyErrorArgKey
val a = view[a_key].unwrap()
```

#### 3A.6. Generic Error behavior (design-only)

For untyped catches (`catch (e)` or `catch Error(e)`):

* The spec continues to allow a more generic, stringly API:

  ```drift
  val code = e.args().key("sql_state").first().unwrap_or("<none>");
  ```

* This workstream **does not** change the generic `Error` API yet.

* Typed args-views are a feature of typed catches, not the generic `Error`.

---

### Step 3B — Compiler + runtime plumbing

This is the implementation of:

* Arg schema emission from the checker.
* Synthetic `ArgKey` / `ArgsView` types.
* `e.args` lowering to an args-view struct.
* Key helper methods and ArgKey-based indexing.
* Runtime backing (`DriftError.args`, `drift_error_new_dummy`, `drift_error_add_arg`, `__exc_args_get`).
* Dot-shortcut desugaring (when grammar catches up).

#### 3B.1. Exception metadata & event codes

**Status:** done.

Compiler work:

* `Checker._register_exceptions` now computes:

  * `arg_order: List[String]` in declaration order.
  * `arg_types: Map[String, Type]`.
  * `event_code: Int` (kind + payload60) used by the runtime.
  * `ExceptionMeta` entries that include `event_code` and `arg_order`.

* The metadata is used later to:

  * Synthesize `<Exc>ArgKey` and `<Exc>ArgsView` types.
  * Drive runtime args table construction.
  * Type-check args-view operations against the declared schema.

Runtime work (relevant to 3B.1):

* `DriftError` struct extended to carry a pointer and count for args:

  ```c
  struct DriftErrorArg {
      DriftString key;
      DriftString value;
  };

  struct DriftError {
      int64_t code;
      DriftString payload;
      struct DriftErrorArg *args;
      size_t arg_count;
  };
  ```

* `drift_error_new_dummy(uint64_t event_code, DriftString key, DriftString payload)`:

  * Stores `event_code` as-is in `code`.
  * Seeds `args` with a single `(key, payload)` pair when `key.len > 0`.
  * Leaves `args == NULL` and `arg_count == 0` when `key` is empty.

* `drift_error_get_arg(const DriftError *err, DriftString key) -> const DriftString *`:

  * Iterates `args[0..arg_count)` to find a matching key.
  * Returns pointer to `value` on hit, `NULL` on miss.

#### 3B.2. Synthetic ArgKey / ArgsView types

**Status:** done.

Compiler work:

* Introduced `StructInfo.is_synthetic` to distinguish synthetic from user structs.

* Added `_define_struct(name, field_types, is_synthetic)` helper in the checker:

  * Defines a struct in `struct_infos`.
  * Registers a constructor signature in `function_infos`.
  * Returns the created `StructInfo`.

* `_register_exceptions` now:

  * Synthesizes `MyErrorArgKey`:

    ```drift
    struct MyErrorArgKey { name: String }
    ```

  * Synthesizes `MyErrorArgsView`:

    ```drift
    struct MyErrorArgsView { error: Error }
    ```

  * Stores the corresponding `StructInfo`s on `ExceptionInfo.arg_key_struct` / `.args_view_struct`.

  * Records the type names in `ExceptionInfo.arg_key_type` / `.args_view_type`.

Type-checking:

* `MyErrorArgsView` is a normal struct type with a single `error: Error` field.
* `MyErrorArgKey` is a normal struct type with a single `name: String` field.
* Both participate in lookup, field access, etc., as regular structs.

#### 3B.3. Compiler-driven key helpers (methods)

**Status:** done.

Compiler work:

* `StructInfo` now tracks `methods: Map[String, FunctionSignature]` for synthetic methods.

* `_register_exceptions` populates, for each `MyErrorArgsView`, methods:

  ```drift
  fn a(self: MyErrorArgsView) returns MyErrorArgKey
  fn b(self: MyErrorArgsView) returns MyErrorArgKey
  ```

* These are stored as `FunctionSignature`s only; their bodies are synthesized in lowering.

Checker work:

* `_resolve_attr_type`:

  * For struct types, checks `struct_info.methods` first:

    * `view.a` → return type `MyErrorArgKey`.
    * `view.b` → return type `MyErrorArgKey`.

* `_resolve_callee` recognizes method calls:

  * `view.a()` resolves to the method `MyErrorArgsView.a`.
  * `_check_call` enforces the synthetic signature (no args, correct receiver).

Lowering work:

* When encountering `view.a()` or `view.b()`:

  * Lowering doesn’t emit a real function call.

  * Instead, it synthesizes a `MyErrorArgKey` struct value:

    ```drift
    MyErrorArgKey(name = "a")
    ```

  * In MIR/SSA, this is a `StructInit` with the field `name` set to a string literal.

#### 3B.4. ExceptionCtor lowering and arg population

**Status:** done (for String-typed args).

Compiler/runtime work:

* `ExceptionCtor` now carries `arg_order` in the AST, preserving the original field order.
* Lowering does:

  * Picks the first field in `arg_order` (if any) as the dummy ctor seed:

    ```drift
    drift_error_new_dummy(event_code, first_key, first_value)
    ```

  * Obtains the returned `Error*` and uses it for subsequent arg additions.

  * For each remaining field `(key, value)` in `arg_order[1:]`:

    ```drift
    drift_error_add_arg(err, key, value)
    ```

Runtime work:

* `drift_error_add_arg(Error *err, DriftString key, DriftString value)`:

  * Reallocates `err->args` to append one more `DriftErrorArg`.
  * Copies `key` and `value` into the new slot.
  * Increments `arg_count`.

Constraint (current implementation):

* Only `String`-typed args are wired into this path so far; non-String args must be formatted to `String` at the checker/IR level before being passed into the ctor/add functions (this is consistent with the “Diagnostic → String” model).

#### 3B.5. Args-view and ArgKey lookup → Option<String>

**Status:** done.

Runtime work:

* Added `DriftOptionString`:

  ```c
  struct DriftOptionString {
      uint8_t is_some;
      struct DriftString value;
  };
  ```

* Added `__exc_args_get(const DriftError *err, DriftString key)`:

  * Calls `drift_error_get_arg(err, key)`.
  * On hit: returns `{ .is_some = 1, .value = *val }`.
  * On miss: returns `{ .is_some = 0, .value = empty_string }`.

Compiler work:

* In `lang/runtime/__init__.py`, registered the builtin signature:

  ```python
  "__exc_args_get": FunctionSignature(
      "__exc_args_get",
      (ERROR, STR),
      Type("Option", args=(STR,)),
      effects=None,
  )
  ```

* SSA/LLVM:

  * `_llvm_type_with_structs(Type("Option", (STR,)))` → `{ i8, DriftString }`, matching `DriftOptionString`.
  * The call site for `__exc_args_get` uses:

    ```llvm
    %res = call { i8, %drift.String } @__exc_args_get(%Error* %err, %drift.String %key)
    ```

Lowering work:

* Args-view indexing (`view[key]`) is recognized by a helper `_maybe_lower_args_view_index`:

  * Lowers the base expression `view`:

    * Confirms its type is a synthetic args-view struct with an `error: Error` field.

  * Lowers the index expression `key`:

    * Confirms its type is the matching `MyErrorArgKey` struct with a `name: String` field.

  * Extracts:

    * `err` via `FieldGet(view, "error")`.
    * `key_name` via `FieldGet(key, "name")`.

  * Emits `Call __exc_args_get(err, key_name)` with result type `Option<String>`.

Checker work:

* `_check_index_expr`:

  * For args-view types:

    * Requires the index type to be `Type(exc.arg_key_type)` (`MyErrorArgKey`).
    * Returns `Type("Option", (STR,))` — i.e., `Option<String>`.

  * For all other containers, falls back to the existing array indexing rule (`Int` index).

#### 3B.6. e.args → args-view

**Status:** done.

Compiler work:

* In typed catches:

  ```drift
  catch MyError(e) {
      e.args
  }
  ```

  is treated as `MyErrorArgsView`.

* Lowering:

  * `e` is lowered to an `Error` SSA value.
  * `e.args` is lowered to a `MyErrorArgsView` struct with:

    ```drift
    MyErrorArgsView(error = e)
    ```

This is the base expression used for both:

* Explicit key-helper usage: `view[view.a()]`.
* Future dot-shortcut usage: `e.args[.a]` (once grammar is added).

#### 3B.7. Tests

**Status:** done.

Runtime tests:

* `tests/runtime_error_dummy_raw.c`:

  * Confirms that `drift_error_new_dummy` preserves the full event code and seeds the args array correctly.

* `tests/runtime_error_args_none.c`:

  * Constructs an error with known args.
  * Calls `__exc_args_get` with a missing key.
  * Asserts `is_some == 0` (None path).

SSA/e2e tests:

* `tests/ssa_programs/exception_args_lookup.drift`:

  * Throws `MyError(a = "AA", b = "BBB")`.

  * In the catch:

    ```drift
    let view = e.args
    let ka = view.a()
    let kb = view.b()
    let la = view[ka].unwrap().len()
    let lb = view[kb].unwrap().len()
    ```

  * Asserts the sum of lengths (happy path through `Option<String>` and `__exc_args_get`).

* `tests/ssa_programs/exception_args_dot_lookup.drift`:

  * Same scenario, but exercises the key helper form explicitly:

    ```drift
    let view = e.args
    let la = view[view.a()].unwrap().len()
    let lb = view[view.b()].unwrap().len()
    ```

  * This is currently the stand-in for dot-shortcut until the grammar supports leading-dot.

---

### Step 3B Status

* **Spec/grammar:** design done; parser **does not yet** implement leading-dot `e.args[.field]` sugar. Tests currently use the explicit key-helper form `view[view.a()]` instead.
* **Compiler/runtime:**

  * Checker emits per-exception arg schema (`event_code`, `arg_order`, `arg_types`).
  * Synthetic `<Exc>ArgKey` / `<Exc>ArgsView` structs are generated and registered.
  * `e.args` materializes the per-exception args-view struct (`{ error: Error }`).
  * Per-field key helpers (`a()`, `b()`, …) are synthesized on the args-view type and return `<Exc>ArgKey`.
  * Args-view indexing `view[key]` expects `<Exc>ArgKey` and returns `Option<String>`, lowering to `__exc_args_get` backed by `DriftError.args` + `drift_error_add_arg`.
  * Runtime helpers `drift_error_new_dummy`, `drift_error_add_arg`, and `__exc_args_get` are implemented and covered by runtime tests (Some/None paths).

* Once grammar is updated, re-enable `e.args[.field]` SSA tests as the primary dot-shortcut example; keep the key-helper form as a supported alternative.
