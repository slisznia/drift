module std.concurrency

import std.core as core;
import std.mem as mem;

use trait core.Borrow;
use trait core.BorrowMut;
use trait core.Destructible;

export {
	Arc,
	arc,
	Mutex,
	MutexGuard,
	mutex,
	lock,
	mutex_guard_get_mut
};

pub struct ArcBox<T> {
	count: Int,
	value: T
}

pub struct Arc<T> {
	buf: mem.RawBuffer<ArcBox<T>>
}

pub fn arc<T>(var value: T) nothrow -> Arc<T> {
	unsafe {
		var buf = mem.alloc_uninit<type ArcBox<T>>(1);
		var slot = mem.ptr_at_mut<type ArcBox<T>>(&mut buf, 0);
		slot.count = 1;
		slot.value = move value;
		return Arc<type T>(buf = move buf);
	}
}

implement<T> Arc<T> {
	pub fn clone(self: &mut Arc<T>) nothrow -> Arc<T> {
		unsafe {
			var slot = mem.ptr_at_mut<type ArcBox<T>>(&mut self.buf, 0);
			slot.count = slot.count + 1;
		}
		val buf_ptr = mem.rawbuffer_ptr<type ArcBox<T>>(&self.buf);
		val buf_cap = mem.rawbuffer_cap<type ArcBox<T>>(&self.buf);
		return Arc<type T>(buf = mem.rawbuffer_from_parts<type ArcBox<T>>(buf_ptr, buf_cap));
	}

	pub fn get(self: &Arc<T>) nothrow -> &T {
		unsafe {
			val slot = mem.ptr_at_ref<type ArcBox<T>>(&self.buf, 0);
			return &slot.value;
		}
	}

	pub fn get_mut(self: &mut Arc<T>) nothrow -> &mut T {
		unsafe {
			val slot = mem.ptr_at_mut<type ArcBox<T>>(&mut self.buf, 0);
			return &mut slot.value;
		}
	}
}

implement<T> core.Borrow<T> for Arc<T> {
	pub fn borrow(self: &Arc<T>) nothrow -> &T {
		return self.get();
	}
}

implement<T> core.BorrowMut<T> for Arc<T> {
	pub fn borrow_mut(self: &mut Arc<T>) nothrow -> &mut T {
		return self.get_mut();
	}
}

implement<T> core.Destructible for Arc<T> {
	pub fn destroy(var self: Arc<T>) nothrow -> Void {
		unsafe {
			var buf = self.buf;
			var inner = mem.read<type ArcBox<T>>(&mut buf, 0);
			inner.count = inner.count - 1;
			if inner.count == 0 {
				core.drop_value<type ArcBox<T>>(inner);
				mem.dealloc<type ArcBox<T>>(self.buf);
			} else {
				mem.write<type ArcBox<T>>(&mut buf, 0, inner);
			}
		}
	}
}

pub struct Mutex<T> {
	locked: Bool,
	value: T
}

pub struct MutexGuard<T> {
	m: &mut Mutex<T>
}

pub fn mutex<T>(value: T) nothrow -> Mutex<T> {
	return Mutex<type T>(locked = false, value = value);
}

pub fn lock<T>(m: &mut Mutex<T>) nothrow -> MutexGuard<T> {
	while m.locked {
	}
	m.locked = true;
	return MutexGuard<type T>(m = m);
}

pub fn mutex_guard_get_mut<T>(g: &mut MutexGuard<T>) nothrow -> &mut T {
	return &mut g.m.value;
}

implement<T> Mutex<T> {
	pub fn lock(self: &mut Mutex<T>) nothrow -> MutexGuard<T> {
		while self.locked {
		}
		self.locked = true;
		return MutexGuard<type T>(m = self);
	}
}

implement<T> MutexGuard<T> {
	pub fn get_mut(self: &mut MutexGuard<T>) nothrow -> &mut T {
		return &mut self.m.value;
	}
}

implement<T> core.BorrowMut<T> for MutexGuard<T> {
	pub fn borrow_mut(self: &mut MutexGuard<T>) nothrow -> &mut T {
		return self.get_mut();
	}
}

implement<T> core.Destructible for MutexGuard<T> {
	pub fn destroy(self: MutexGuard<T>) nothrow -> Void {
		self.m.locked = false;
	}
}
