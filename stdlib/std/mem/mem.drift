module std.mem

export { Ptr, RawBuffer, MaybeUninit, alloc_uninit, dealloc, capacity, ptr_at_ref, ptr_at_mut, write, read, ptr_from_ref, ptr_from_ref_mut, ptr_offset, ptr_read, ptr_write, ptr_is_null, replace, swap, maybe_uninit, maybe_write, maybe_assume_init_ref, maybe_assume_init_mut, maybe_assume_init_read };

import std.core as core;

pub struct RawBuffer<T> {
	ptr: Ptr<Byte>
	cap: Int
}

pub const RAW_BUFFER_CONTAINER_ID: String = "std.mem:RawBuffer";

pub struct MaybeUninit<T> { }

@intrinsic pub unsafe fn alloc_uninit<T>(cap: Int) -> RawBuffer<T>;

@intrinsic pub unsafe fn dealloc<T>(buf: RawBuffer<T>) -> Void;

pub fn capacity<T>(buf: &RawBuffer<T>) -> Int {
	return buf.cap;
}

@intrinsic pub unsafe fn ptr_at_ref<T>(buf: &RawBuffer<T>, i: Int) -> &T;

@intrinsic pub unsafe fn ptr_at_mut<T>(buf: &mut RawBuffer<T>, i: Int) -> &mut T;

@intrinsic pub unsafe fn write<T>(buf: &mut RawBuffer<T>, i: Int, v: T) -> Void;

@intrinsic pub unsafe fn read<T>(buf: &mut RawBuffer<T>, i: Int) -> T;

@intrinsic pub unsafe fn ptr_from_ref<T>(r: &T) -> Ptr<T>;

@intrinsic pub unsafe fn ptr_from_ref_mut<T>(r: &mut T) -> Ptr<T>;

@intrinsic pub unsafe fn ptr_offset<T>(p: Ptr<T>, offset: Int) -> Ptr<T>;

@intrinsic pub unsafe fn ptr_read<T>(p: Ptr<T>) -> T;

@intrinsic pub unsafe fn ptr_write<T>(p: Ptr<T>, v: T) -> Void;

@intrinsic pub unsafe fn ptr_is_null<T>(p: Ptr<T>) -> Bool;

@intrinsic pub fn replace<T>(ptr: &mut T, v: T) -> T;

@intrinsic pub fn swap<T>(a: &mut T, b: &mut T) -> Void;

implement<T> core.Copy for Ptr<T> { }

@intrinsic pub unsafe fn maybe_uninit<T>() -> MaybeUninit<T>;

@intrinsic pub unsafe fn maybe_write<T>(slot: &mut MaybeUninit<T>, v: T) -> &mut T;

@intrinsic pub unsafe fn maybe_assume_init_ref<T>(slot: &MaybeUninit<T>) -> &T;

@intrinsic pub unsafe fn maybe_assume_init_mut<T>(slot: &mut MaybeUninit<T>) -> &mut T;

@intrinsic pub unsafe fn maybe_assume_init_read<T>(slot: &mut MaybeUninit<T>) -> T;
