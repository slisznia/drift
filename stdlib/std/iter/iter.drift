module std.iter

import std.core as core;

export {
	Iterable,
	SinglePassIterator,
	MultiPassIterator,
	BidirectionalIterator,
	RandomAccessReadable,
	RandomAccessPermutable,
	StringBytesIter
};

pub trait Iterable<Src, Item, Iter> require Iter is SinglePassIterator<Item> {
	fn iter(src: Src) nothrow -> Iter;
}

pub trait SinglePassIterator<T> {
	fn next(self: &mut Self) -> Optional<T>;
}

pub trait MultiPassIterator<T> require Self is SinglePassIterator<T>, Self is core.Copy {
}

pub trait BidirectionalIterator<T> require Self is MultiPassIterator<T> {
	fn prev(self: &mut Self) -> Optional<T>;
}

pub trait RandomAccessReadable<T> {
	fn len(self: &Self) -> Int;
	fn compare_at(self: &Self, i: Int, j: Int) -> Int;
}

pub trait RandomAccessPermutable<T> require Self is RandomAccessReadable<T> {
	fn swap(self: &mut Self, i: Int, j: Int) -> Void;
}

pub struct StringBytesIter {
	s: String,
	idx: Int,
	len: Int
}

implement String {
	pub fn bytes(self: &String) nothrow -> StringBytesIter {
		val len = byte_length(self);
		// MVP: struct fields cannot be references, so we store a String handle copy.
		return StringBytesIter(s = *self, idx = 0, len = len);
	}
}

implement Iterable<&String, Byte, StringBytesIter> for &String {
	pub fn iter(self: &String) nothrow -> StringBytesIter {
		return self.bytes();
	}
}

implement SinglePassIterator<Byte> for StringBytesIter {
	pub fn next(self: &mut StringBytesIter) -> Optional<Byte> {
		if self.idx >= self.len {
			return Optional::None();
		}
		val b = core.string_byte_at(&self.s, self.idx);
		self.idx = self.idx + 1;
		return Optional::Some(b);
	}
}
