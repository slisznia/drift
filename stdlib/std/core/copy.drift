module std.core

import std.core.hash as hash;
import std.mem as mem;

use trait hash.Hasher;

export {
	Copy,
	Destructible,
	Diagnostic,
	Result,
	Fn0,
	Fn1,
	Fn2,
	Borrow,
	BorrowMut,
	Callback0,
	Callback1,
	Callback2,
	Cell,
	cell,
	void_value,
	drop_value,
	callback0,
	callback1,
	callback2,
	STRING_CONTAINER_ID,
	string_byte_at
};

pub trait Copy {
}

pub trait Destructible {
	fn destroy(self: Self) nothrow -> Void;
}

pub trait Diagnostic {
	fn to_diag(self: Self) nothrow -> DiagnosticValue;
}

pub trait Borrow<T> {
	fn borrow(self: &Self) nothrow -> &T;
}

pub trait BorrowMut<T> {
	fn borrow_mut(self: &mut Self) nothrow -> &mut T;
}

pub variant Result<T, E> {
	Ok(value: T),
	Err(err: E),
}

pub trait Fn0<R> {
	fn call(self: &Self) nothrow -> R;
}

pub trait Fn1<A, R> {
	fn call(self: &Self, a: A) nothrow -> R;
}

pub trait Fn2<A, B, R> {
	fn call(self: &Self, a: A, b: B) nothrow -> R;
}

pub fn void_value() nothrow -> Void {
	return;
}

pub struct Cell<T> {
	value: T
}

pub fn cell<T>(var value: T) nothrow -> Cell<T> {
	return Cell<type T>(value = move value);
}

implement<T> Cell<T> {
	pub fn get(self: &Cell<T>) nothrow -> T require T is Copy {
		return self.value;
	}

	pub fn set(self: &Cell<T>, var value: T) nothrow -> Void {
		unsafe {
			val ptr = mem.ptr_from_ref<type T>(&self.value);
			mem.ptr_write<type T>(ptr, move value);
		}
	}
}

pub interface Callback0<R> {
	fn call(self: &Self) nothrow -> R;
}

pub interface Callback1<A, R> {
	fn call(self: &Self, a: A) nothrow -> R;
}

pub interface Callback2<A, B, R> {
	fn call(self: &Self, a: A, b: B) nothrow -> R;
}

@intrinsic pub fn callback0<F, R>(f: F) nothrow -> Callback0<R> require F is Fn0<R>;
@intrinsic pub fn callback1<F, A, R>(f: F) nothrow -> Callback1<A, R> require F is Fn1<A, R>;
@intrinsic pub fn callback2<F, A, B, R>(f: F) nothrow -> Callback2<A, B, R> require F is Fn2<A, B, R>;
@intrinsic pub fn drop_value<T>(value: T) nothrow -> Void;

implement Copy for Int {
}

implement Copy for Uint {
}

implement Copy for Uint64 {
}

implement Copy for Bool {
}

implement Copy for Float {
}

implement Copy for Byte {
}

implement Copy for String {
}

implement Copy for Void {
}

implement<T> Copy for &T {
}

implement<T> Copy for Optional<T> require T is Copy {
}

implement<T> Copy for mem.Ptr<T> {
}

implement Diagnostic for Int {
	pub fn to_diag(self: Int) nothrow -> DiagnosticValue {
		return DiagnosticValue::Int(self);
	}
}

implement Diagnostic for Uint {
	pub fn to_diag(self: Uint) nothrow -> DiagnosticValue {
		return DiagnosticValue::Int(self);
	}
}

implement Diagnostic for Bool {
	pub fn to_diag(self: Bool) nothrow -> DiagnosticValue {
		return DiagnosticValue::Bool(self);
	}
}

implement Diagnostic for Float {
	pub fn to_diag(self: Float) nothrow -> DiagnosticValue {
		return DiagnosticValue::Float(self);
	}
}

implement Diagnostic for String {
	pub fn to_diag(self: String) nothrow -> DiagnosticValue {
		return DiagnosticValue::String(self);
	}
}

implement Diagnostic for DiagnosticValue {
	pub fn to_diag(self: DiagnosticValue) nothrow -> DiagnosticValue {
		return move self;
	}
}

pub const STRING_CONTAINER_ID: String = "std.core:String";

@intrinsic pub fn string_byte_at(s: &String, i: Int) -> Byte;
