module std.core

import std.core.hash as hash;

use trait hash.Hasher;

export {
	Copy,
	Destructible,
	Diagnostic,
	Fn0,
	Fn1,
	Fn2,
	Borrow,
	BorrowMut,
	Callback0,
	Callback1,
	Callback2,
	drop_value,
	callback0,
	callback1,
	callback2,
	STRING_CONTAINER_ID,
	string_byte_at
};

pub trait Copy {
}

pub trait Destructible {
	fn destroy(self: Self) nothrow -> Void;
}

pub trait Diagnostic {
	fn to_diag(self: Self) nothrow -> DiagnosticValue;
}

pub trait Borrow<T> {
	fn borrow(self: &Self) nothrow -> &T;
}

pub trait BorrowMut<T> {
	fn borrow_mut(self: &mut Self) nothrow -> &mut T;
}

pub trait Fn0<R> {
	fn call(self: &Self) -> R;
}

pub trait Fn1<A, R> {
	fn call(self: &Self, a: A) -> R;
}

pub trait Fn2<A, B, R> {
	fn call(self: &Self, a: A, b: B) -> R;
}

pub interface Callback0<R> {
	fn call(self: &Self) nothrow -> R;
}

pub interface Callback1<A, R> {
	fn call(self: &Self, a: A) nothrow -> R;
}

pub interface Callback2<A, B, R> {
	fn call(self: &Self, a: A, b: B) nothrow -> R;
}

@intrinsic pub fn callback0<F, R>(f: F) -> Callback0<R> require F is Fn0<R>;
@intrinsic pub fn callback1<F, A, R>(f: F) -> Callback1<A, R> require F is Fn1<A, R>;
@intrinsic pub fn callback2<F, A, B, R>(f: F) -> Callback2<A, B, R> require F is Fn2<A, B, R>;
@intrinsic pub fn drop_value<T>(value: T) nothrow -> Void;

implement Copy for Int {
}

implement Copy for Uint {
}

implement Copy for Uint64 {
}

implement Copy for Bool {
}

implement Copy for Float {
}

implement Copy for Byte {
}

implement Copy for String {
}

implement Copy for Void {
}

implement<T> Copy for &T {
}

implement<T> Copy for Optional<T> require T is Copy {
}

implement Diagnostic for Int {
	pub fn to_diag(self: Int) nothrow -> DiagnosticValue {
		return DiagnosticValue::Int(self);
	}
}

implement Diagnostic for Uint {
	pub fn to_diag(self: Uint) nothrow -> DiagnosticValue {
		return DiagnosticValue::Int(self);
	}
}

implement Diagnostic for Bool {
	pub fn to_diag(self: Bool) nothrow -> DiagnosticValue {
		return DiagnosticValue::Bool(self);
	}
}

implement Diagnostic for Float {
	pub fn to_diag(self: Float) nothrow -> DiagnosticValue {
		return DiagnosticValue::Float(self);
	}
}

implement Diagnostic for String {
	pub fn to_diag(self: String) nothrow -> DiagnosticValue {
		return DiagnosticValue::String(self);
	}
}

implement Diagnostic for DiagnosticValue {
	pub fn to_diag(self: DiagnosticValue) nothrow -> DiagnosticValue {
		return move self;
	}
}

pub const STRING_CONTAINER_ID: String = "std.core:String";

@intrinsic pub fn string_byte_at(s: &String, i: Int) -> Byte;
